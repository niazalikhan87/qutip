#summary Calculating correlation functions
#labels correlation

= Correlation functions =

Here we demonstrate how to calculate two-time correlation functions in QuTiP. Using the quantum regression theorem, we can apply the equation of motion for the system itself also to calculate two-time correlation functions. In QuTiP, there are family functions that assists in this process: *correlation_ode*, *correlation_es*, *correlation_mc*, and *correlation_ss_ode*, *correlation_ss_es*, *correlation_ss_mc*. As the names suggest, these functions use the ODE, the exponential series, and the Monte-Carlo solvers, respectively, to evolve the correlation functions in time. The following table describes in detail the usage of each function:

|| *Function* || *Input parameters* || *Usage* ||
|| `correlation_ss_es` || `H` - the Hamiltonian, `tlist` - list of times to evaluate the correlation function, `c_op_list` - list of collapse operators, `a_op` and `b_op` - the operators for which to calculate correlations. || Calculates the steady state correlation <a(0)b(tau)>, using the Exponential series solver. ||
|| `correlation_ss_ode` || Same as above. || Calculates the steady state correlation <a(0)b(tau)>, using the ODE solver. ||
|| `correlation_ss_mc`  || Same as above. || Calculates the steady state correlation <a(0)b(tau)>, using the Monte-Carlo evolution. ||
|| `correlation_es` || `H` - the Hamiltonian, `rho0` - initial state of the system, `t1list` and `t2list`- list of times to evaluate the correlation function (t1 for operator `a` and t1+t2 for operator `b`), `c_op_list` - list of collapse operators, `a_op` and `b_op` - the operators for which to calculate correlations. || Calculates the correlation <a(t1)b(t1+t2)>, using the Exponential series solver. ||
|| `correlation_ode` || Same as above. || Calculates the  correlation <a(t1)b(t1+t2)>, using the ODE solver. ||
|| `correlation_mc`  || Same as above. || Calculates the correlation <a(t1)b(t1+t2)>, using the Monte-Carlo evolution. ||

The most common use-case is to calculate correlation functions of the kind `<a(0)b(t)>`, in which case we use the correlation function solvers that start from the steady state, i.e., the *correlation_ss_xxx* functions. These functions return a vector (in general complex) with the correlations between the operators as a function of the difference time. 

The following code demonstrates how to calculate the `<x(0)x(t)>` correlation for a leaky cavity with three different relaxation rates:
{{{
>> tlist = linspace(0,10.0,200);
>> a  = destroy(10)
>> x  = a.dag() + a
>> H  = a.dag()*a
>> 
>> corr1 = correlation_ss_ode(H, tlist, [sqrt(0.5)*a], x, x)
>> corr2 = correlation_ss_ode(H, tlist, [sqrt(1.0)*a], x, x)
>> corr3 = correlation_ss_ode(H, tlist, [sqrt(2.0)*a], x, x)
>> 
>> from pylab import *
>> plot(tlist, real(corr1), tlist, real(corr2), tlist, real(corr3))
>> xlabel('Time')
>> ylabel('Correlation <x(0)x(t)>')
>>
}}}

http://qutip.googlecode.com/svn/wiki/images/guide-correlation-1.png

More generally, we can also calculate correlation functions of the kind `<a(t1)b(t1+t2)>`,
i.e., the correlation function of a system that is not in its steadystate. In QuTiP,
we can evoluate such correlation functions using the functions *correlation_xxx*. 
These functions returns a matrix with the correlations as a function of the two 
time coordinates:

{{{
>> tlist = linspace(0,10.0,200);
>> a  = destroy(10)
>> x  = a.dag() + a
>> H  = a.dag()*a
>> alpha = 2.5
>> corr = correlation_ode(H, coherent_dm(10, alpha), tlist, tlist, [sqrt(0.25)*a], x, x)
>> 
>> from pylab import *
>> pcolor(corr)
>> xlabel('Time t2')
>> ylabel('Time t1')
>> title('Correlation <x(t1)x(t1+t2)>')
>> show()
}}}

|| http://qutip.googlecode.com/svn/wiki/images/guide-correlation-2.png alpha = 2.5 || http://qutip.googlecode.com/svn/wiki/images/guide-correlation-3.png  alpha = 0.0 ||

Notice that in the figure above to the right, where `alpha = 0.0` and the system therefore initially is in its groundstate, that the correlations does not depend on the `t1` coordinate, and we could in this case have used the steadystate solver to only calculate the `t2` dependence. 
