#summary An overview of exponential series.

= Exponential-series representation of time-dependent quantum objects =

The eseries object in QuTiP is a representation of an exponential-series expansion of time-dependent quantum objects (a concept borrowed from the quantum optics toolbox). 

An exponential series is parameterized by its amplitude coefficients `c_i` and rates `r_i`, so that the series takes the form `eseries(t) = sum_i c_i exp(r_i * t)`. The coefficients are typically quantum objects (type Qobj: states, operators, etc.), so that the value of the eseries also is a quantum object, and the rates can be either real or complex numbers (describing decay rates and oscillation frequencies, respectively). Note that all amplitude coefficients in an exponential series must be of the same dimensions and composition. 

In QuTiP, an exponential series object is constructed by creating an instance of the class *eseries*,
{{{
>> es1 = eseries(sigmax(), 1j)
}}}
where the first argument is the amplitude coefficient (here, the sigma-X operator), and the second argument is the rate. The eseries in this example represents the time-dependent operator `sigmax() * exp(1j * t)`. 

To add more terms to an *eseries* object we simply add *eseries* object using the `+` operator:
{{{
>> es2 = eseries(0.5 * sigmax(), 1j * omega) + eseries(0.5 * sigmax(), -1j * omega)
}}}
The *eseries* in this example represents the operator `0.5 * sigmax() * exp(i * omega * t) + 0.5 * sigmax() * exp(i * omega * t)`, which is the exponential series representation of `sigmax() * cos(omega * t)`

We can inspect the structure of an *eseries* object by printing it:
{{{
>> print es2
ESERIES object: 2 terms
Hilbert space dimensions: [[2], [2]]
Exponent #0 = 1j
Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = True
Qobj data = 
[[ 0.   0.5]
 [ 0.5  0. ]]

Exponent #1 = -1j
Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = True
Qobj data = 
[[ 0.   0.5]
 [ 0.5  0. ]]
}}}

and we can evaluate it for time `t` by using the *esval* function
{{{
>>> esval(es2, 0.0)
Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = True
Qobj data = 
[[ 0.+0.j  1.+0.j]
 [ 1.+0.j  0.+0.j]]
}}}
or for a list of times `[0.0, 1.0 * pi, 2.0 * pi]`
{{{
>>> esval(es2, [0.0, 1.0 * pi, 2.0 * pi])
[
Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = True
Qobj data = 
[[ 0.+0.j  1.+0.j]
 [ 1.+0.j  0.+0.j]]
, Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = True
Qobj data = 
[[ 0.+0.j -1.+0.j]
 [-1.+0.j  0.+0.j]]
, Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = True
Qobj data = 
[[ 0.+0.j  1.+0.j]
 [ 1.+0.j  0.+0.j]]
]
}}}

To calculate the expectation value of an operator for a system with a state described by an *eseries*, we use the *expect* function. For example, consider the operator `sigmax() * cos(omega * t) + sigmaz() * sin(omega * t)`, and say we would like to know the expectation value of this operator for a spin in its excited state (`rho = fock_dm(2,1)` produce this state):
{{{
>> es3 = eseries([0.5*sigmaz(), 0.5*sigmaz()], [1j, -1j]) + eseries([-0.5j*sigmax(), 0.5j*sigmax()], [1j, -1j])
>> rho = fock_dm(2, 1)
>> es3_expect = expect(rho, es3)
>> print es3_expect
ESERIES object: 2 terms
Hilbert space dimensions: [[1, 1]]
Exponent #0 = -1j
(-0.5+0j)
Exponent #1 = 1j
(-0.5+0j)
>> print es3_expect.value([0.0, pi/2])
[ -1.00000000e+00+0.j  -6.12303177e-17+0.j]
}}}
Note the expectation value of the *eseries* `expect(rho, es3)` itself is an *eseries*, but with amplitude coefficients that are C-numbers instead of quantum operators. To evaluate the C-number *eseries* at times `tlist` we use `esval(es3_expect, tlist)`, or, equivalently, `es3_expect.value(tlist)`.