#summary Time-evolution of quantum systems.

In this section we describe how to set up time-evolution simulations of closed
and open quantum systems. 

= Unitary evolution =

The Schrödinger equation, which governs the time-evolution of closed quantum
systems, is defined by its Hamiltonian and state vector. In the previous section,
[GuideComposite Creating and manipulating composite objects with tensor and ptrace],
we showed how Hamiltonians and state vectors are constructed in QuTiP.
Given a Hamiltonian, we can calculate the unitary (non-dissipative)
time-evolution of an arbitrary state vector *psi0* using the QuTiP function
*[Functions#ode_solve(H,rho0,tlist,c_op_list,expt_op_list,&H_args) ode_solve()]*.
It evolves the state vector and evaluates the expectation values for a set of 
operators *expt_op_list* at the points in time in the list *tlist*,
using an ordinary differential equation solver. 

For example, the time evolution of a quantum spin-1/2 system with tunneling
rate 0.1 that initially is in the up state is calculated, and the 
expectation values of the sigma-Z operator evaluated, with the following code: 
{{{
>> H = 2 * pi * 0.1 * sigmax()
>> psi0 = basis(2, 0)
>> tlist = linspace(0.0, 10.0, 20.0)
>> ode_solve(H, psi0, tlist, [], [sigmaz()])
array([[ 1.00000000+0.j,  0.78914229+0.j,  0.24548596+0.j, -0.40169696+0.j,
        -0.87947669+0.j, -0.98636356+0.j, -0.67728166+0.j, -0.08257676+0.j,
         0.54695235+0.j,  0.94582040+0.j,  0.94581706+0.j,  0.54694422+0.j,
        -0.08258520+0.j, -0.67728673+0.j, -0.98636329+0.j, -0.87947111+0.j,
        -0.40168898+0.j,  0.24549302+0.j,  0.78914528+0.j,  0.99999927+0.j]])
}}}
The brackets in the fourth argument is an empty list of collapse operators, 
since we consider unitary evolution in this example. See the next section for examples
on how dissipation is included by defining a list of collapse operators.

The function returns an array of expectation values for the operators that are
included in the list in the fifth argument. Adding operators to this
list results in a larger output array returned by the function (one list of
numbers, corresponding to the times in tlist, for each operator):
{{{
>> ode_solve(H, psi0, tlist, [], [sigmaz(), sigmay()])
array([[  1.00000000e+00+0.j,   7.89142292e-01+0.j,   2.45485961e-01+0.j,
         -4.01696962e-01+0.j,  -8.79476686e-01+0.j,  -9.86363558e-01+0.j,
         -6.77281655e-01+0.j,  -8.25767574e-02+0.j,   5.46952346e-01+0.j,
          9.45820404e-01+0.j,   9.45817056e-01+0.j,   5.46944216e-01+0.j,
         -8.25852032e-02+0.j,  -6.77286734e-01+0.j,  -9.86363287e-01+0.j,
         -8.79471112e-01+0.j,  -4.01688979e-01+0.j,   2.45493023e-01+0.j,
          7.89145284e-01+0.j,   9.99999271e-01+0.j],
       [  0.00000000e+00+0.j,  -6.14214010e-01+0.j,  -9.69403055e-01+0.j,
         -9.15775807e-01+0.j,  -4.75947716e-01+0.j,   1.64596791e-01+0.j,
          7.35726839e-01+0.j,   9.96586861e-01+0.j,   8.37166184e-01+0.j,
          3.24695883e-01+0.j,  -3.24704840e-01+0.j,  -8.37170685e-01+0.j,
         -9.96585195e-01+0.j,  -7.35720619e-01+0.j,  -1.64588257e-01+0.j,
          4.75953748e-01+0.j,   9.15776736e-01+0.j,   9.69398541e-01+0.j,
          6.14206262e-01+0.j,  -8.13905967e-06+0.j]])
}}}
The resulting list of expectation values can easily be visualized using
matplotlib's plotting functions:
{{{
>> tlist = linspace(0.0, 10.0, 100)
>> expt_list = ode_solve(H, psi0, tlist, [], [sigmaz(), sigmay()])
>> 
>> from pylab import *
>> plot(tlist, real(expt_list[0]))
>> plot(tlist, real(expt_list[1]))
>> xlabel('Time')
>> ylabel('Expectation values')
>> legend(("Simga-Z", "Sigma-Y"))
>> show()
}}}

http://qutip.googlecode.com/svn/wiki/images/guide-qubit-dynamics.png

If an empty list of operators is passed as fifth parameter, the *ode_solve* function
returns a list of state vectors for the times specified in *tlist*.
{{{
>> tlist = [0.0, 1.0]
>> ode_solve(H, psi0, tlist, [], [])
[
Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket
Qobj data = 
[[ 1.+0.j]
 [ 0.+0.j]]
, Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket
Qobj data = 
[[ 0.80901765+0.j        ]
 [ 0.00000000-0.58778584j]]
, Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket
Qobj data = 
[[ 0.3090168+0.j        ]
 [ 0.0000000-0.95105751j]]
, Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket
Qobj data = 
[[-0.30901806+0.j        ]
 [ 0.00000000-0.95105684j]]
]
}}}


= Non-unitary evolution: Master equation =

For non-unitary evolution of a quantum systems, i.e., evolution that includes
incoherent processes such as relaxation and dephasing, it is common to use
master equations. In QuTiP, the same function (*ode_solve*) is used for 
evolution both according to the Schrödinger equation and to the master equation,
even though these two equations of motion are very different. The *ode_solve*
function automatically determines if it is sufficient to use the Schrödinger 
equation (if no collapse operators were given) or if it has to use the
master equation (if collapse operators were given). Note that to calculate
the time evolution according to the Schrödinger equation is easier and much
faster (for large systems) than using the master equation, so if possible the
solver will fall back on using the Schrödinger equation.

What is new in the master equation compared to the Schrödinger equation are
processes that describe dissipation in the quantum system due to its interaction
with an environment. These environmental interactions are defined by the
operators through which the system couples to the environment, and rates that
describe the strength of the processes.

In QuTiP, the product of the square root of the rate and the operator that 
describe the dissipation process is called a collapse operator. A list of 
collapse operators (*c_op_list*) is passed as the fourth argument to the 
*ode_solve* function in order to define the dissipation processes in the master
eqaution. When the *c_op_list* isn't empty, the *ode_solve* function will use
the master equation instead of the unitary Schröderinger equation.

Using the example with the spin dynamics from the previous section, we can
easily add a relaxation process (describing the dissipation of energy from the
spin to its environment), by adding `sqrt(0.05) * sigmax()` to
the previously empty list in the fourth parameter to the *ode_solve* function:
{{{
>> tlist = linspace(0.0, 10.0, 100)
>> expt_list = ode_solve(H, psi0, tlist, [sqrt(0.05) * sigmax()], [sigmaz(), sigmay()])
>> 
>> from pylab import *
>> plot(tlist, real(expt_list[0]))
>> plot(tlist, real(expt_list[1]))
>> xlabel('Time')
>> ylabel('Expectation values')
>> legend(("Sigma-Z", "Sigma-Y"))
>> show()
}}}
Here, `0.05` is the rate and the operator `sigmax()` describes the dissipation 
process.

http://qutip.googlecode.com/svn/wiki/images/guide-qubit-dynamics-dissip.png

Now a slightly more complex example: Consider a two-level atom coupled to a leaky single-mode cavity through a dipole-type interaction, which supports a coherent exchange of quanta between the two systems. If the atom initially is in its groundstate and the cavity in a 5-photon fock state, the dynamics is calculated with the lines following code:
{{{
>> tlist = linspace(0.0, 10.0, 200)
>> psi0 = tensor(fock(2,0), fock(10, 5))
>> a  = tensor(qeye(2), destroy(10))
>> sm = tensor(destroy(2), qeye(10))
>> H = 2*pi * a.dag() * a + 2 * pi * sm.dag() * sm + 2*pi * 0.25 * (sm*a.dag() + sm.dag() * a)
>> expt_list = ode_solve(H, psi0, tlist, ntraj, [sqrt(0.1)*a], [a.dag()*a, sm.dag()*sm])
>> 
>> from pylab import *
>> plot(tlist, real(expt_list[0]))
>> plot(tlist, real(expt_list[1]))
>> xlabel('Time')
>> ylabel('Expectation values')
>> legend(("cavity photon number", "atom excitation probability"))
>> show()
}}}

http://qutip.googlecode.com/svn/wiki/images/guide-jc-dynamics.png

= Non-unitary evolution: Monte-Carlo evolution =

Quantum trajectory Monte-Carlo is an alternative approach for calculating the
time-evolution of dissipative quantum systems. Unlike the master equation, 
the Monte-Carlo method is based on the unitary evolution and uses the state
vector instead of density matrix to describe the state of the system.
Dissipation is introduced into the dynamics by stochastic quantum jumps,
whose rate and effect on the state of the system is described by the same
collapse operators that are used to define the master equation. The average of
a large number of such stochastic trajectories describes the dissipative 
dynamics of the system, and has been shown to give identical results as the
master equation. 

In QuTiP, Monto-Carlo evolution is implemented with the
*mcsolve* function. It takes nearly the same arguments as the *ode_solve*
function for master-equation evolution, expect for one additional parameter
`ntraj` (fourth parameter), which define the number of stochastic trajectories
that should be averaged. This number should usually be in the range 100 - 500 to
give a smooth results (although the optimal number for `ntraj` can vary from
case to case).

To illustrate the use of the Monte-Carlo evolution of quantum systems in QuTiP,
let's again consider the case of a two-level atom coupled to a leaky cavity. The 
only differences to the master-equation treatment is that in this case we 
invoke the *mcsolve* function instead of *ode_solve*, and a new parameter 
`ntraj = 250` has been defined.
{{{
>> tlist = linspace(0.0, 10.0, 200)
>> psi0 = tensor(fock(2,0), fock(10, 5))
>> a  = tensor(qeye(2), destroy(10))
>> sm = tensor(destroy(2), qeye(10))
>> H = 2*pi * a.dag() * a + 2 * pi * sm.dag() * sm + 2*pi * 0.25 * (sm*a.dag() + sm.dag() * a)
>> ntraj = 250
>> expt_list = mcsolve(H, psi0, tlist, [sqrt(0.1)*a], [a.dag()*a, sm.dag()*sm])
>> 
>> from pylab import *
>> plot(tlist, real(expt_list[0]))
>> plot(tlist, real(expt_list[1]))
>> title('Monte-Carlo time evolution')
>> xlabel('Time')
>> ylabel('Expectation values')
>> legend(("cavity photon number", "atom excitation probability"))
>> show()
}}}

http://qutip.googlecode.com/svn/wiki/images/guide-mc-dynamics.png

The advantage of the Monte-Carlo method over the master equation approach is that
only the state vector is required to be kept in the computer memory (as opposed to
the entire density matrix). For large quantum system this becomes a significant
advantage and the Monte-Carlo is therefore generally recommended for such systems.
But on the other hand, for small systems the added overhead of averaging a large 
number of stochastic trajectories to obtain the open system dynamics does not
outwieght the benefits of the (small) memory saving, 
and master equations are therefore generally more efficient for small quantum systems.


= Evolution with time-dependent Hamiltonians (unitary and non-unitary) =

In the previous examples of quantum system evolution, we assumed that
the systems under consideration were described by a time-independent
Hamiltonian. The two main evolution solvers in QuTiP, *ode_solve* and
*mcsolve*, can also handle time-dependent Hamiltonians. If a callback function
is passed as first parameter to the solver function (instead of *Qobj*
Hamiltonian), then this function is called at each time step and is expected
to return the *Qobj* Hamiltonian for that point in time. The callback function
takes two arguments: the time `t` and list additional Hamiltonian arguments
`H_args`. This list of additional arguments is the same object as is passed
as the sixth parameter to the solver function (only used for time-dependent
Hamiltonians).

For example, let's consider a two-level system with energy splitting 1.0, and
subject to a time-dependent field that couples to the Sigma-X operator with 
amplitude 0.1. Furthermore, to make the example a little bit more interesting,
let's also assume that the two-level system is subject to relaxation, with 
relaxation rate 0.01. The following code calculates the dynamics of the system
in the absence and in the presence of the time-dependent driving signal:
{{{
>> def hamiltonian_t(t, args):
>>     H0 = args[0]
>>     H1 = args[1]
>>     w  = args[2]
>>     return H0 + H1 * sin(w * t)
>> 
>> H0 = - 2*pi * 0.5  * sigmaz()
>> H1 = - 2*pi * 0.05 * sigmax() 
>> H_args = (H0, H1, 2*pi*1.0)
>> psi0 = fock(2, 0)                   # intial state |0>
>> c_op_list = [sqrt(0.01) * sigmam()] # relaxation
>> tlist = arange(0.0, 50.0, 0.01)
>>
>> expt_sz    = ode_solve(H0, psi0, tlist, c_op_list, [sigmaz()])
>> expt_sz_td = ode_solve(hamiltonian_t, psi0, tlist, c_op_list, [sigmaz()], H_args)
>> 
>> from pylab import *
>> plot(tlist, expt_sz[0],    'r')
>> plot(tlist, expt_sz_td[0], 'b')
>> ylabel("Expectation value of Sigma-Z")
>> xlabel("time")
>> legend(("H = H0", "H = H0 + H1 * sin(w*t)"), loc=4)
>> show()
}}}

http://qutip.googlecode.com/svn/wiki/images/guide-td-dynamics.png



















