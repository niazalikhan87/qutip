#Function list

This is a complete, alphabetical, function list for QuTiP.  Examples are also given where appropriate.  Arguments with the #-sign are optional.
*<wiki:toc max_depth="2" />*

= A =

==about()==
    @brief Displays QuTiP about box.

----

= B = 

==basis(N,#m)==
    @brief Generates the vector representation of a bosonic number state.
    
    @param *N* the number of states in the Hilbert space
    
    @param *m* `int` corresponding to desired number state, defaults to 0 if omitted
    
    @returns *Qobj* quantum object representing the requested number state |args>

{{{
basis(5,3)
Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket
Qobj data = 
[[ 0.]
 [ 0.]
 [ 0.]
 [ 1.]
 [ 0.]]
}}}

----

=C=

==clebsch(j1,j2,j3,m1,m2,m3)==
    @brief  Calculates the Clebsch-Gordon coefficient for coupling (j1,m1) and (j2,m2) to give (j3,m3).

    @param *j1* 

    @param *j2*

    @param *j3*

    @param *m1*

    @param *m2*

    @param *m3*

----
==correlation_es(H, rho0, tlist, taulist, c_op_list, a_op, b_op)==
     @brief   Calculate a two-time correlation function <A(t+tau)B(t)> using exponential series and the quantum regression theorem.

    @param *H*              ` Qobj`  system Hamiltonian

    @param *rho0*          `Qobj`  initial density matrix

    @param *tlist*           `list`/`array` of times

    @param *taulist*       `list`/`array` of tau times

    @param *c_op_list*   `list` of collapse operators

    @param *a_op*          `Qobj` of A operator

    @param *b_op*          `Qobj` of B operator
----

==correlation_ode(H, rho0, tlist, taulist, c_op_list, a_op, b_op)==
    @brief   Calculate a two-time correlation function <A(t+tau)B(t)> using the ode solver, and the quantum regression theorem. 

    @param *H*              ` Qobj`  system Hamiltonian

    @param *rho0*          `Qobj`  initial density matrix

    @param *tlist*           `list`/`array` of times

    @param *taulist*       `list`/`array` of tau times

    @param *c_op_list*   `list` of collapse operators

    @param *a_op*          `Qobj` of A operator

    @param *b_op*          `Qobj` of B operator

----

==correlation_mc(H, psi0, tlist, taulist, c_op_list, a_op, b_op)==
    @brief   Calculate a two-time correlation function <A(t+tau)B(t)> using the Monte-Carle solver, and the quantum regression theorem.. 

    @param *H*              ` Qobj`  system Hamiltonian

    @param *rho0*          `Qobj`  initial density matrix

    @param *tlist*           `list`/`array` of times

    @param *taulist*       `list`/`array` of tau times

    @param *c_op_list*   `list` of collapse operators

    @param *a_op*          `Qobj` of A operator

    @param *b_op*          `Qobj` of B operator

----

==cnot()==
    @brief   Quantum object representing the CNOT gate.

    @returns *Qobj*    CNOT quantum object
{{{
cnot()
Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True
Qobj data = 
[[ 1.  0.  0.  0.]
 [ 0.  1.  0.  0.]
 [ 0.  0.  0.  1.]
 [ 0.  0.  1.  0.]]
}}}
----

==create(N)==
    @brief Bosonic creation (raising) operator for Hilbert space with dimension N

    @param *N* number of levels in truncated  Hilbert space

    @returns *Qobj* quantum object for creation operator on truncated Hilbert space
{{{
create(4)
Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False
Qobj data = 
[[ 0.          0.          0.          0.        ]
 [ 1.          0.          0.          0.        ]
 [ 0.          1.41421356  0.          0.        ]
 [ 0.          0.          1.73205081  0.        ]]
}}}
----
=D=
==destroy(N)==
    @brief Bosonic destruction (lowering) operator for Hilbert space with dimension N

    @param *N* number of levels in truncated  Hilbert space

    @returns *Qobj* quantum object for destruction operator on truncated Hilbert space
{{{
destroy(4)
Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False
Qobj data = 
[[ 0.          1.          0.          0.        ]
 [ 0.          0.          1.41421356  0.        ]
 [ 0.          0.          0.          1.73205081]
 [ 0.          0.          0.          0.        ]]
}}}
----
=E=
==expect(oper,state)==
    @brief calculates the expectation value for operator *oper* in state *state*

    @param *oper* quantum object representing an operator

    @param *state* quantum object representing a quantum state or density matrix

    @returns *float* if operator is Hermitian; possibly *complex* if operator is _not_ Hermitian
{{{
expect(num(4),basis(4,3))
3.0
}}}
----

=F=
==fredkin()==
    @brief quantum object representing the Fredkin gate.

    @returns *Qobj* quantum object for Fedkin gate
{{{
fredkin()
Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = [8, 8], type = oper, isHerm = True
Qobj data = 
[[ 1.  0.  0.  0.  0.  0.  0.  0.]
 [ 0.  1.  0.  0.  0.  0.  0.  0.]
 [ 0.  0.  1.  0.  0.  0.  0.  0.]
 [ 0.  0.  0.  1.  0.  0.  0.  0.]
 [ 0.  0.  0.  0.  1.  0.  0.  0.]
 [ 0.  0.  0.  0.  0.  0.  1.  0.]
 [ 0.  0.  0.  0.  0.  1.  0.  0.]
 [ 0.  0.  0.  0.  0.  0.  0.  1.]]
}}}
----
=G=

=H=
==hadamard()==
    @brief  quantum object representing the Hadamard gate.

    @returns *Qobj* quantum object for Hadamard gate
{{{
hadamard()
Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = True
Qobj data = 
[[ 0.70710678  0.70710678]
 [ 0.70710678 -0.70710678]]
}}}
----

=I=

=J=
==jmat(j,#s)==
    @brief generates spin matrices corresponding to a given spin value j

    @param *j* `int` or half-`int` value of spin

    @param *s* `str` representing requested operator: 'x', 'y', 'z', '+', '-'.  Returns `array` of ['x', 'y', 'z'] quantum objects if *s* is not given.
{{{
jmat(3/2.,'x')
Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = True
Qobj data = 
[[ 0.         0.8660254  0.         0.       ]
 [ 0.8660254  0.         1.         0.       ]
 [ 0.         1.         0.         0.8660254]
 [ 0.         0.         0.8660254  0.       ]]

jmat(1/2.)
Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = True
Qobj data = 
[[ 0.   0.5]
 [ 0.5  0. ]]
Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = True
Qobj data = 
[[ 0.+0.j   0.+0.5j]
 [ 0.-0.5j  0.+0.j ]]
Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = True
Qobj data = 
[[ 0.5  0. ]
 [ 0.  -0.5]]
}}}
----

=K=

=L=

=M=

=N=
==num(N)==
    @brief Number operator on N-dimensional Hilbert space

    @param *N* number of levels in truncated  Hilbert space

    @returns *Qobj* number operator on N-dimensional Hilbert space
{{{
num(4)
Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = True
Qobj data = 
[[0 0 0 0]
 [0 1 0 0]
 [0 0 2 0]
 [0 0 0 3]]
}}}
----
=O=

=P=
==parfor(func,frange)==
    @brief Parallel execution of a for-loop over single-variable function 'func()' for values in list 'frange'

    @param *func* single-variable function

    @param *frange* `list`/`array` of values for which to evaluate function *func*

   @returns *array* an array with length equal to the number of output parameters from *func* with elements consisting of arrays containing return values from evaluating *func* at values in *frange*.
 
    See [DrivenCavitySS] example.
----

==phasegate(theta)==
    @brief quantum object representation of phase gate with angle theta

    @param *theta* angle of phase rotation, exp(1j*theta).

    @returns *Qobj*  quantum object for phase gate with angle theta.
{{{
phasegate(pi/8)
Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = False
Qobj data = 
[[ 1.00000000+0.j          0.00000000+0.j        ]
 [ 0.00000000+0.j          0.92387953+0.38268343j]]
}}}
----
=Q=
==qeye(N)==
    @brief Identity operator for N-dimensional Hilbert space

    @param *N* number of levels in truncated  Hilbert space

    @returns *Qobj* Identity operator on N-dimensional Hilbert space
{{{
qeye(3)
Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True
Qobj data = 
[[ 1.  0.  0.]
 [ 0.  1.  0.]
 [ 0.  0.  1.]]
}}}
----
=R=

=S=
==sigmam()==
    @brief lowering (sigma-minus) operator for Pauli spins

    @returns *Qobj* quantum object for sigma-minus operator
{{{
sigmam()
Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = False
Qobj data = 
[[ 0.  0.]
 [ 1.  0.]]
}}}
----

==sigmap()==
    @brief raising (sigma-plus) operator for Pauli spins

    @returns *Qobj* quantum object for sigma-plus operator
{{{
sigmap()
Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = False
Qobj data = 
[[ 0.  1.]
 [ 0.  0.]]
}}}
----

==sigmax()==
    @brief Quantum object for Pauli sigma-x operator

    @returns *Qobj* quantum object for sigma-x
{{{
sigmax()
Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = True
Qobj data = 
[[ 0.  1.]
 [ 1.  0.]]
}}}
----

==sigmay()==
    @brief Quantum object for Pauli sigma-y operator

    @returns *Qobj* quantum object for sigma-y
{{{
sigmay()
Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = True
Qobj data = 
[[ 0.+0.j  0.-1.j]
 [ 0.+1.j  0.+0.j]]
}}}
----

==sigmaz()==
    @brief Quantum object for Pauli sigma-z operator

    @returns *Qobj* quantum object for sigma-z
{{{
sigmaz()
Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = True
Qobj data = 
[[ 1.  0.]
 [ 0. -1.]]
}}}
----

==swap()==
    @brief quantum object representing swap gate.

    @returns *Qobj* quantum object for swap gate
{{{
swap()
Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True
Qobj data = 
[[ 1.  0.  0.  0.]
 [ 0.  0.  1.  0.]
 [ 0.  1.  0.  0.]
 [ 0.  0.  0.  1.]]
}}}
----
=T=
==toffoli()==
    @brief quantum operator for Toffoli gate.
 
    @returns *Qobj* quantum object for Toffoli gate
{{{
toffoli()
Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = [8, 8], type = oper, isHerm = True
Qobj data = 
[[ 1.  0.  0.  0.  0.  0.  0.  0.]
 [ 0.  1.  0.  0.  0.  0.  0.  0.]
 [ 0.  0.  1.  0.  0.  0.  0.  0.]
 [ 0.  0.  0.  1.  0.  0.  0.  0.]
 [ 0.  0.  0.  0.  1.  0.  0.  0.]
 [ 0.  0.  0.  0.  0.  1.  0.  0.]
 [ 0.  0.  0.  0.  0.  0.  0.  1.]
 [ 0.  0.  0.  0.  0.  0.  1.  0.]]
}}}
----
=U=

=V=

=W=

=X=

=Y=

=Z=
















