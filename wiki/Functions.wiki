#Function list

This is a (*not yet*) complete, alphabetical, function list for QuTiP.  Examples are also given where appropriate.  Arguments with the &-sign are optional.
*<wiki:toc max_depth="2" />*

= A =

==about()==
    @brief Displays the QuTiP about box.

----

= B = 
==Bloch()==
    @brief Class for plotting vectors and data points on the Bloch sphere.

    See *[GuideBloch Plotting on the Bloch sphere]* for further information
----

==basis(N,&m)==
    @brief Generates the vector representation of a bosonic number state.
    
    @param *N* the number of states in the Hilbert space
    
    @param *m* `int` corresponding to desired number state, defaults to 0 if omitted
    
    @returns *Qobj* quantum object representing the requested number state |args>
{{{
basis(5,3)
Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket
Qobj data = 
[[ 0.]
 [ 0.]
 [ 0.]
 [ 1.]
 [ 0.]]
}}}
----

=C=

==clebsch(j1,j2,j3,m1,m2,m3)==
    @brief  Calculates the Clebsch-Gordon coefficient for coupling (j1,m1) and (j2,m2) to give (j3,m3).
    
    @param *j1* 
    
    @param *j2*
    
    @param *j3*
    
    @param *m1*
    
    @param *m2*
    
    @param *m3*

----

==coherent(N,alpha)==
    @brief Generates a coherent state with eigenvalue alpha in a N-dimensional Hilbert space via displacement operator on vacuum state
    
    @param *N* number of levels in truncated  Hilbert space
    
    @param *alpha* eigenvalue for coherent state
    
    @returns *Qobj* quantum object for coherent state
{{{
coherent(4,0.5*0.5j)
Quantum object: dims = [[4], [1]], shape = [4, 1], type = ket
Qobj data = 
[[ 0.96923323+0.j        ]
 [ 0.00000000+0.24230859j]
 [-0.04282883+0.j        ]
 [ 0.00000000-0.00626025j]]
}}}
----

==coherent_dm(N, alpha)== 
    @brief Generate the density matrix representation of a coherent state via outer product
    
    @param *N* number of levels in truncated Hilbert space
    
    @param *alpha* eigenvalue for coherent state
    
    @returns *Qobj* density matrix representation of coherent state
{{{
coherent_dm(3,0.5j)
Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True
Qobj data = 
[[ 0.77901768+0.j          0.00000000-0.38817824j -0.14651550+0.j        ]
 [ 0.00000000+0.38817824j  0.19342609+0.j          0.00000000-0.07300749j]
 [-0.14651550+0.j          0.00000000+0.07300749j  0.02755623+0.j        ]]
}}}
----

==correlation_es(H, rho0, tlist, taulist, c_op_list, a_op, b_op)==
     @brief   Calculate a two-time correlation function <A(t+tau)B(t)> using exponential series and the quantum regression theorem.
     
    @param *H*              ` Qobj`  system Hamiltonian
    
    @param *rho0*          `Qobj`  initial density matrix
    
    @param *tlist*           `list`/`array` of times
    
    @param *taulist*       `list`/`array` of tau times
    
    @param *c_op_list*   `list` of collapse operators
    
    @param *a_op*          `Qobj` of A operator
    
    @param *b_op*          `Qobj` of B operator
----

==correlation_ode(H, rho0, tlist, taulist, c_op_list, a_op, b_op)==
    @brief   Calculate a two-time correlation function <A(t+tau)B(t)> using the ode solver, and the quantum regression theorem. 
    
    @param *H*              ` Qobj`  system Hamiltonian
    
    @param *rho0*          `Qobj`  initial density matrix
    
    @param *tlist*           `list`/`array` of times
    
    @param *taulist*       `list`/`array` of tau times
    
    @param *c_op_list*   `list` of collapse operators
    
    @param *a_op*          `Qobj` of A operator
    
    @param *b_op*          `Qobj` of B operator

----

==correlation_mc(H, psi0, tlist, taulist, c_op_list, a_op, b_op)==
    @brief   Calculate a two-time correlation function <A(t+tau)B(t)> using the Monte-Carle solver, and the quantum regression theorem.. 
    
    @param *H*              ` Qobj`  system Hamiltonian
    
    @param *rho0*          `Qobj`  initial density matrix
    
    @param *tlist*           `list`/`array` of times
    
    @param *taulist*       `list`/`array` of tau times
    
    @param *c_op_list*   `list` of collapse operators
    
    @param *a_op*          `Qobj` of A operator
    
    @param *b_op*          `Qobj` of B operator

----

==cnot()==
    @brief   Quantum object representing the CNOT gate.
    
    @returns *Qobj*    CNOT quantum object
{{{
cnot()
Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True
Qobj data = 
[[ 1.  0.  0.  0.]
 [ 0.  1.  0.  0.]
 [ 0.  0.  0.  1.]
 [ 0.  0.  1.  0.]]
}}}
----

==create(N)==
    @brief Bosonic creation (raising) operator for Hilbert space with dimension N
    
    @param *N* number of levels in truncated  Hilbert space
    
    @returns *Qobj* quantum object for creation operator on truncated Hilbert space
{{{
create(4)
Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False
Qobj data = 
[[ 0.          0.          0.          0.        ]
 [ 1.          0.          0.          0.        ]
 [ 0.          1.41421356  0.          0.        ]
 [ 0.          0.          1.73205081  0.        ]]
}}}
----
=D=

==demos()==
    @brief Displays a list of demo scripts built into QuTiP.
----

==destroy(N)==
    @brief Bosonic destruction (lowering) operator for Hilbert space with dimension N
    
    @param *N* number of levels in truncated Hilbert space
    
    @returns *Qobj* quantum object for destruction operator on truncated Hilbert space
{{{
destroy(4)
Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False
Qobj data = 
[[ 0.          1.          0.          0.        ]
 [ 0.          0.          1.41421356  0.        ]
 [ 0.          0.          0.          1.73205081]
 [ 0.          0.          0.          0.        ]]
}}}
----

==displace(N,alpha)==
    @brief Single mode displacement operator for Hilbert space of dimension N and amplitude alpha

	@param *N* number of levels in truncated Hilbert space
	
	@param *alpha* displacement amplitude (and phase)
	
	@returns *Qobj* quantum object representing displacement operator
{{{
displace(3,0.25j)
Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = False
Qobj data = 
[[ 0.96923524+0.j          0.00000000+0.24226042j -0.04350794+0.j        ]
 [ 0.00000000+0.24226042j  0.90770572+0.j          0.00000000+0.34260797j]
 [-0.04350794+0.j          0.00000000+0.34260797j  0.93847048+0.j        ]]
}}}
----

=E=

==entropy_vn(rho,&base)==
    @brief Calculates the Von-Neumann entropy of a given density matrix.

    @param *rho* Quantum object representing density matrix

    @param *base* Base of logarithm, either '2' or 'e'. Default base='2'

    @returns *float* Entropy of density matrix rho

    See example: *[ExamplesEntropy]*
----

==expect(oper,state)==
    @brief calculates the expectation value for operator *oper* in state *state*
    
    @param *oper* quantum object representing an operator
    
    @param *state* quantum object representing a quantum state or density matrix
    
    @returns *float* if operator is Hermitian; possibly *complex* if operator is _not_ Hermitian
{{{
expect(num(4),basis(4,3))
3.0
}}}
----

=F=
==fidelity(A,B)==
    @brief Calculates the fidelity (pseudo-metric) between two density matricies.  See: Nielsen & Chuang, "Quantum Computation and Quantum Information".
    
    @param *A* density matrix quantum object
    
    @param *B* density matrix with same dimensions as A
    
    @returns *float* fidelity
{{{
x=coherent_dm(5,sqrt(2)*1.0j)
y=thermal_dm(5,1)
fidelity(x,y)
0.42968726436823845
}}}
----

==fock(N,&m)==
    @brief Generates the vector representation of a bosonic Fock (number) state.  Same as *[Functions#basis(N,&m) basis]* 
    
    @param *N* the number of states in the Hilbert space
    
    @param *m* `int` corresponding to desired number state, defaults to 0 if omitted
    
    @returns *Qobj* quantum object representing the requested number state |args>
{{{
fock(4,2)
Quantum object: dims = [[4], [1]], shape = [4, 1], type = ket
Qobj data = 
[[ 0.]
 [ 0.]
 [ 1.]
 [ 0.]]    
}}}
----

==fock_dm(N,m)== 
    @brief Generate the density matrix representation of a Fock state via outer product
    
    @param *N* number of levels in truncated Hilbert space
    
    @param *m* `int` corresponding to desired number state, defaults to 0 if omitted
    
    @returns *Qobj* density matrix representation of Fock state
{{{
fock_dm(4,2)
Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = True
Qobj data = 
[[ 0.  0.  0.  0.]
 [ 0.  0.  0.  0.]
 [ 0.  0.  1.  0.]
 [ 0.  0.  0.  0.]]
}}}
----

==fredkin()==
    @brief quantum object representing the Fredkin gate.
    
    @returns *Qobj* quantum object for Fedkin gate
{{{
fredkin()
Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = [8, 8], type = oper, isHerm = True
Qobj data = 
[[ 1.  0.  0.  0.  0.  0.  0.  0.]
 [ 0.  1.  0.  0.  0.  0.  0.  0.]
 [ 0.  0.  1.  0.  0.  0.  0.  0.]
 [ 0.  0.  0.  1.  0.  0.  0.  0.]
 [ 0.  0.  0.  0.  1.  0.  0.  0.]
 [ 0.  0.  0.  0.  0.  0.  1.  0.]
 [ 0.  0.  0.  0.  0.  1.  0.  0.]
 [ 0.  0.  0.  0.  0.  0.  0.  1.]]
}}}
----
=G=

=H=
==hadamard()==
    @brief  quantum object representing the Hadamard gate.
    
    @returns *Qobj* quantum object for Hadamard gate
{{{
hadamard()
Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = True
Qobj data = 
[[ 0.70710678  0.70710678]
 [ 0.70710678 -0.70710678]]
}}}
----

=I=
==isbra(Q)==
    @brief checks if quantum object corresponds to a bra vector
    
    @param *Q* quantum object to be tested
    
    @returns *True* if object is a bra, *False* otherwise
----

==ischeck(Q)==
    @brief determines type of quantum structure
    
    @param *Q* quantum object to be tested
    
    @returns *str* type of structure: 'ket', 'bra', 'oper', or 'super'
----

==isherm(Q)==
    @brief checks if quantum object corresponds to a Hermitian operator
    
    @param *Q* quantum object to be tested
    
    @returns *True* if object is Hermitian operator, *False* otherwise
----

==isket(Q)==
    @brief checks if quantum object corresponds to a ket vector
    
    @param *Q* quantum object to be tested
    
    @returns *True* if object is a ket, *False* otherwise
----

==isoper(Q)==
    @brief checks if quantum object corresponds to a operator
    
    @param *Q* quantum object to be tested
    
    @returns *True* if object is operator, *False* otherwise
----

==issuper(Q)==
    @brief checks if quantum object corresponds to a super-operator
    
    @param *Q* quantum object to be tested
    
    @returns *True* if object is super-operator, *False* otherwise
----

=J=
==jmat(j,&s)==
    @brief generates spin matrices corresponding to a given spin value j
    
    @param *j* `int` or half-`int` value of spin
    
    @param *s* `str` representing requested operator: 'x', 'y', 'z', '+', '-'.  Returns `array` of ['x', 'y', 'z'] quantum objects if *s* is not given.
{{{
jmat(3/2.,'x')
Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = True
Qobj data = 
[[ 0.         0.8660254  0.         0.       ]
 [ 0.8660254  0.         1.         0.       ]
 [ 0.         1.         0.         0.8660254]
 [ 0.         0.         0.8660254  0.       ]]

jmat(1/2.)
Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = True
Qobj data = 
[[ 0.   0.5]
 [ 0.5  0. ]]
Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = True
Qobj data = 
[[ 0.+0.j   0.+0.5j]
 [ 0.-0.5j  0.+0.j ]]
Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = True
Qobj data = 
[[ 0.5  0. ]
 [ 0.  -0.5]]
}}}
----

=K=
==ket2dm(Q)==
    @brief Takes input ket or bra vector and returns density matrix formed by outer product.
    
    @param *Q* Ket or bra vector
    
    @returns *Qobj* Density matrix formed by outer product
{{{
ket2dm(basis(3,2)) 
Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True
Qobj data = 
[[ 0.  0.  0.]
 [ 0.  0.  0.]
 [ 0.  0.  1.]]
}}}
----

=L=
==liouvillian(H, c_op_list)==
    @brief Assembles the Liouvillian superoperator from a Hamiltonian and a list of collapse operators.
    
    @param *H* Hamiltonian 
    
    @param *c_op_list* list of collpase operators
    
    @returns *Qobj* quantum object for Louvillian superoperator
----

=M=

==mcsolve(H,psi0,tlist,ntraj,collapse_ops,expect_ops,&options=Odeoptions())==
    @brief Monte-Carlo evolution of a state vector |psi> for a given Hamiltonian and sets of collapse operators and operators for calculating expectation values.  Options for solver are given by the Mcoptions class.
    
    @param *H* quantum object representing system Hamiltonian
    
    @param *psi0* quantum object for initial state vector 
    
    @param *tlist* `list`/`array` of times at which to evaluate state or expectation values
    
    @param *ntraj* `int` representing the number of Monte-Carlo trajectories to run.
    
    @param *collapse_ops* `list` of collapse operators
    
    @param *expect_ops* `list` of operators to calculate expectation values
    
    @param *options* optional settings for ODE solver given by the Odeoptions class.
----
=N=
==num(N)==
    @brief Number operator on N-dimensional Hilbert space
    
    @param *N* number of levels in truncated  Hilbert space
    
    @returns *Qobj* number operator on N-dimensional Hilbert space
{{{
num(4)
Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = True
Qobj data = 
[[0 0 0 0]
 [0 1 0 0]
 [0 0 2 0]
 [0 0 0 3]]
}}}
----
=O=

==Odeoptions()==
    @brief Class of options for the ODE solvers used by odesolve and mcsolve.
----

==odesolve(H, rho0, tlist, c_op_list, expt_op_list, &H_args)==

    Evolution of a state vector or density matrix (rho0) for a given
    Hamiltonian (H) and set of collapse operators (c_op_list), by integrating
    the set of ordinary differential equations that define the system. The
    output is either the state vector at arbitray points in time (tlist), or
    the expectation values of the supplied operators (expt_op_list). 

    For problems with time-dependent Hamiltonians, H can be a callback function
    that takes two arguments, time and H_args, and returns the Hamiltonian
    at that point in time. H_args is a list of parameters that is
    passed to the callback function H (only used for time-dependent Hamiltonians).
----

==orbital(theta,phi,state)==
    @brief Calculates an angular wave function on a sphere at the mesh of points defined by theta     and phi.  Each ket must have 2l+1 components for some integer l.

    @param *theta* list of points defining angles with respect to z-axis

    @param *phi* list of points defining angle in x-y plane

    @param *state* ket to be converted to angular wavefunction on mesh defined by theta and phi

    @returns array of values for wavefunction evaluated at mesh points defined by theta and phi.
----

=P=
==parfor(func,frange)==
    @brief Parallel execution of a for-loop over single-variable function 'func()' for values in list 'frange'
    
    @param *func* single-variable function
    
    @param *frange* `list`/`array` of values for which to evaluate function *func*
    
   @returns *array* an array with length equal to the number of output parameters from *func* with elements consisting of arrays containing return values from evaluating *func* at values in *frange*.
 
    See *[GuideParfor Guide to parfor]* or *[ExamplesDrivenCavitySS Steady-state driven cavity]* example.
----

==phasegate(theta)==
    @brief quantum object representation of phase gate with angle theta
    
    @param *theta* angle of phase rotation, exp(1j*theta).
    
    @returns *Qobj*  quantum object for phase gate with angle theta.
{{{
phasegate(pi/8)
Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = False
Qobj data = 
[[ 1.00000000+0.j          0.00000000+0.j        ]
 [ 0.00000000+0.j          0.92387953+0.38268343j]]
}}}
----
==propagator(H, t, c_op_list, &H_args)==
    Calculate the propagator U(t) for the density matrix or wave function such that 

    psi(t) = U(t) psi(0) 

    or 

    rho_vec(t) = U(t) rho_vec(0)

    where rho_vec is the vector representation of the density matrix.
----
==propagator_steadystate(U)==
    Find the steady state for successive applications of the propagator U.
----
==ptrace(rho,sel)==
    @brief partial trace of composite quantum object formed by *[Functions#tensor(args) tensor]*
    
    @param *rho* density matrix of composite quantum object
    
    @param *sel* Integer or list of integers for components to keep.
    
    @returns *Qobj* Density matrix quantum object with components from sel.
----

=Q=
==qstate(str)==
    @brief 	Creates a tensor product for a set of qubits in either the 'up' |0> or 'down' |1> state.
    
    @param *str* String containing 'u' or 'd' for each qubit (ex. 'ududd')
    
    @returns *Qobj* Tensor product corresponding to input string.
{{{
qstate('udu')
Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = [8, 1], type = ket
Qobj data = 
[[ 0.]
 [ 0.]
 [ 0.]
 [ 0.]
 [ 0.]
 [ 1.]
 [ 0.]
 [ 0.]]
}}}
----

==qeye(N)==
    @brief Identity operator for N-dimensional Hilbert space
    
    @param *N* number of levels in truncated Hilbert space
    
    @returns *Qobj* Identity operator on N-dimensional Hilbert space
{{{
qeye(3)
Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True
Qobj data = 
[[ 1.  0.  0.]
 [ 0.  1.  0.]
 [ 0.  0.  1.]]
}}}
----
=R=

=S=
==sigmam()==
    @brief lowering (sigma-minus) operator for Pauli spins
    
    @returns *Qobj* quantum object for sigma-minus operator
{{{
sigmam()
Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = False
Qobj data = 
[[ 0.  0.]
 [ 1.  0.]]
}}}
----

==sigmap()==
    @brief raising (sigma-plus) operator for Pauli spins
    
    @returns *Qobj* quantum object for sigma-plus operator
{{{
sigmap()
Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = False
Qobj data = 
[[ 0.  1.]
 [ 0.  0.]]
}}}
----

==sigmax()==
    @brief Quantum object for Pauli sigma-x operator
    
    @returns *Qobj* quantum object for sigma-x
{{{
sigmax()
Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = True
Qobj data = 
[[ 0.  1.]
 [ 1.  0.]]
}}}
----

==sigmay()==
    @brief Quantum object for Pauli sigma-y operator
    
    @returns *Qobj* quantum object for sigma-y
{{{
sigmay()
Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = True
Qobj data = 
[[ 0.+0.j  0.-1.j]
 [ 0.+1.j  0.+0.j]]
}}}
----

==sigmaz()==
    @brief Quantum object for Pauli sigma-z operator
    
    @returns *Qobj* quantum object for sigma-z
{{{
sigmaz()
Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = True
Qobj data = 
[[ 1.  0.]
 [ 0. -1.]]
}}}
----

==simdiag(ops)==
    @brief Simulateous diagonalization of communting Hermitian matricies
    
    @param *ops* list of commuting, Hermitian operators
    
    @returns *eigvecs,eigvals* array of quantum objects corresponding to simultaneous eigenvectors; array of eigenvalues for each operator along rows.
    
    See GHZ example for usage
----

==sphereplot(theta,phi,values,&save)==
    @brief Plots a array of values on a sphere

    @param *theta* Angle with respect to z-axis

    @param *phi* Angle in x-y plane

    @param *values* Data set to be plotted

    @param *save* Whether to save the figure or not (Figure can always be saved after being displayed.)

    @returns None
----

==spost(A)==
    @brief Super operator formed from post-multiplication by operator A
    
    @param *A* quantum operator for post multiplication
    
    @returns *Qobj* superoperator formed from input qauntum object
----

==spre(A)==
    @brief Super operator formed from pre-multiplication by operator A
    
    @param *A* quantum operator for pre-multiplication
    
    @returns *Qobj* superoperator formed from input qauntum object
----

==squeez(N,sp)==
	@brief Single mode squeezing operator for Hilbert space of dimension N and squeezing parameter sp
    
	@param: *N* size of truncated Hilbert space
    
	@param *sp* squeezing parameter
    
	@returns *Qobj* quantum object for squeezing operator
{{{
squeez(3,0.2j)
Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = False
Qobj data = 
[[ 0.99001666+0.j          0.00000000+0.j          0.00000000-0.14095042j]
 [ 0.00000000+0.j          1.00000000+0.j          0.00000000+0.j        ]
 [ 0.00000000-0.14095042j  0.00000000+0.j          0.99001666+0.j        ]]
}}}
----

==steady(L,&maxiter=100=,&tol=1e-6)==
   @brief Calculate the steady state for the evolution subject to the supplied Louvillian using the inverse power method. See any Linear Algebra book with a iterative methods section for details.
   
   @param *L* Louvillian superoperator
   
   @param *maxiter* Max number of iterations to perform, default = 100
 
   @param *tol* Tolerance, default = 1e-6
 
   @returns *Qobj* State vector corresponding to steady state of system.

   See *[GuideSteadyState Guide to Steady state solver]* for more details
----

==steadystate(H, c_op_list,&maxiter=100,&tol=1e-6)==
    @brief Calculate the steady state for the evolution subject to the supplied Hamiltonian and lsit of collapse operators. Does nothing more than form the Louvillian for you and call *[Functions#steady(L) steady]*.
    
    @param *H* Hamiltonian operator
    
    @param *c_op_list* List of collapse operators
 
    @param *maxiter* Max number of iterations to perform, default = 100  
    
    @param *tol* Tolerance, default = 1e-6
    
    @returns *Qobj* State vector corresponding to steady state of system.

    See *[GuideSteadyState Guide to Steady state solver]* for more details
----

==swap()==
    @brief quantum object representing swap gate.
    
    @returns *Qobj* quantum object for swap gate
{{{
swap()
Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True
Qobj data = 
[[ 1.  0.  0.  0.]
 [ 0.  0.  1.  0.]
 [ 0.  1.  0.  0.]
 [ 0.  0.  0.  1.]]
}}}
----

=T=
==tensor(args)==
    @brief calculates tensor product from input operators
    
    @param *args* a comma seperated list of quantum objects or lists of quantum objects, i.e args=q1,`[q2,q3,q4]`
    
    @returns *Qobj* compoposite quantum object
    
    See examples at [GuideComposite]
----

==thermal_dm(N, n)==
    @brief Generates the density matrix for a single-mode thermal state with n particles
    
    @param *N* number of levels in truncated Hilbert space
    
    @param *n* expectation value for number of particles in thermal state
    
    @returns *Qobj* quantum object representing single-mode thermal density matrix 
{{{
thermal_dm(5,2)
Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isHerm = True
Qobj data = 
[[ 0.33333333  0.          0.          0.          0.        ]
 [ 0.          0.22222222  0.          0.          0.        ]
 [ 0.          0.          0.14814815  0.          0.        ]
 [ 0.          0.          0.          0.09876543  0.        ]
 [ 0.          0.          0.          0.          0.06584362]]
}}}
----

==toffoli()==
    @brief quantum operator for Toffoli gate.
 
    @returns *Qobj* quantum object for Toffoli gate
{{{
toffoli()
Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = [8, 8], type = oper, isHerm = True
Qobj data = 
[[ 1.  0.  0.  0.  0.  0.  0.  0.]
 [ 0.  1.  0.  0.  0.  0.  0.  0.]
 [ 0.  0.  1.  0.  0.  0.  0.  0.]
 [ 0.  0.  0.  1.  0.  0.  0.  0.]
 [ 0.  0.  0.  0.  1.  0.  0.  0.]
 [ 0.  0.  0.  0.  0.  1.  0.  0.]
 [ 0.  0.  0.  0.  0.  0.  0.  1.]
 [ 0.  0.  0.  0.  0.  0.  1.  0.]]
}}}
----

==tracedist(A,B)==
    @brief Calculates the trace distance between two density matricies.  See: Nielsen & Chuang, "Quantum Computation and Quantum Information"
    
    @param *A* density matrix quantum object
    
    @param *B* density matrix quantum object with same dimensions as A
    
    @returns *float* trace distance
{{{
x=coherent_dm(5,sqrt(2)*1.0j)
y=thermal_dm(5,1)
tracedist(x,y)
0.818555240587471
}}}
----
=U=

=V=

=W=

=X=

=Y=

=Z=