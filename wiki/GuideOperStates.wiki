#brief intro into manipulating quantum operators and states.
*<wiki:toc max_depth="1" />*

= Introduction =
In the previous guide section *[GuideBasics]* we saw how to create operators and states, using the functions built into QuTiP.  In this portion of the guide, we will look at performing basic operations with states and operators.  For more detailed demonstrations on how to use and manipulate these objects, see the *[Examples Examples]* section of the WIKI.

= Combining states and operators = 

Here we begin by creating a Fock (basis) vacuum state vector with 5 number states, 0 -> 4:
{{{
vec=basis(5,0)
print vec

Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket
Qobj data = 
[[ 1.]  #<-- |0>
 [ 0.]  #<-- |1>
 [ 0.]  #<-- |2>
 [ 0.]  #<-- |3>
 [ 0.]] #<-- |4>
}}}
and then create a lowering operator corresponding to 5 number states using the `destroy()` function:
{{{
a=destroy(5)
print a

Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isHerm = False
Qobj data = 
[[ 0.          1.          0.          0.          0.        ]
 [ 0.          0.          1.41421356  0.          0.        ]
 [ 0.          0.          0.          1.73205081  0.        ]
 [ 0.          0.          0.          0.          2.        ]
 [ 0.          0.          0.          0.          0.        ]]

}}}
Now lets apply the destruction operator to our vacuum state `vec':
{{{
a*vec

Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket
Qobj data = 
[[ 0.]
 [ 0.]
 [ 0.]
 [ 0.]
 [ 0.]]
}}}

We see that, as expected, the vacuum is transformed to the zero vector.  A more interesting example comes from using the adjoint of the lowering operator, the raising operator:
{{{
a.dag()*vec

Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket
Qobj data = 
[[ 0.]
 [ 1.]  #<-- |1>
 [ 0.]
 [ 0.]
 [ 0.]]
}}}

The raising operator has in indeed raised the state `vec` from the vacuum to the |1> state.  Instead of using the dagger (`dag()) command to raise the state, we could have also used the built in `create()` function to make a raising operator:

{{{
c=create(5)
c*vec()
Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket
Qobj data = 
[[ 0.]
 [ 1.]
 [ 0.]
 [ 0.]
 [ 0.]]
}}}
which obviously does the same thing.  We can of course raise the vacuum state more than once:
{{{
c*c*vec

Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket
Qobj data = 
[[ 0.        ]
 [ 0.        ]
 [ 1.41421356] #<-- |2>
 [ 0.        ]
 [ 0.        ]]
}}}
or just taking the square of the raising operator:
{{{
c**2*vec

Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket
Qobj data = 
[[ 0.        ]
 [ 0.        ]
 [ 1.41421356]
 [ 0.        ]
 [ 0.        ]]
}}}
Applying the raising operator twice gives the expected sqrt(n+1) dependence.  We can use the product of `c*a` to also apply the number operator to the state vector `vec`:
{{{
c*a*vec

Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket
Qobj data = 
[[ 0.]
 [ 0.]
 [ 0.]
 [ 0.]
 [ 0.]]
}}}
or on the |1> state:
{{{
c*a*(c*vec)

Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket
Qobj data = 
[[ 0.]
 [ 1.]
 [ 0.]
 [ 0.]
 [ 0.]]
}}}
or the |2> state:
{{{
c*a*(c**2*vec)

Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket
Qobj data = 
[[ 0.        ]
 [ 0.        ]
 [ 2.82842712]
 [ 0.        ]
 [ 0.        ]]

}}}
Notice how in this last example, application of the number operator does not give the expected value n=2, but rather sqrt(2)*2.  This is because this last state is not normalized to unity as c*|n>=sqrt(n+1)*|n+1>.  Therefore, we should normalize our vector first:
{{{
c*a*(c**2*vec).unit()

Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket
Qobj data = 
[[ 0.]
 [ 0.]
 [ 2.]
 [ 0.]
 [ 0.]]
}}}
Since we are giving a demonstration of using states and operators, we have done a lot more work than we should have.  For example, we do not need to operate on the vacuum state to generate a higher number fock state.  Instead we can use the basis (or fock) function to directly obtain the required state:
{{{
vec=basis(5,2)
print vec

Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket
Qobj data = 
[[ 0.]
 [ 0.]
 [ 1.]
 [ 0.]
 [ 0.]]
}}}
Notice how it is automatically normalized.  We can also use the built in number operator:
{{{
n=num(5)
print n

Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isHerm = True
Qobj data = 
[[0 0 0 0 0]
 [0 1 0 0 0]
 [0 0 2 0 0]
 [0 0 0 3 0]
 [0 0 0 0 4]]
}}}
Therefore, instead of `c*a*(c**2*vec).unit()` we have:
{{{
n*vec

Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket
Qobj data = 
[[ 0.]
 [ 0.]
 [ 2.]
 [ 0.]
 [ 0.]]
}}}


