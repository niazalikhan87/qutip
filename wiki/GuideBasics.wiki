#Intro to the Qobj class

= First things first =

To load the qutip modules, we must first call the import statement:
{{{
from qutip import *
}}}

= The quantum object class =

== Intro ==
The key difference between classical and quantum mechanics lies in the use of operators instead of numbers as variables.  Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems we need a data structure that is capable of encapsulating the properties of a quantum operator and ket/bra vectors.  The quantum object class, Qobj, accomplishes this using matrix representation.

To begin, let us create a blank Qobj: *(in Python, Objects differ from functions in the use of a beginning capital letter)*

{{{
Qobj() 
}}}

which returns `<qutip.Qobj.Qobj instance at 0x3cfbfc8>` indicating that we have created a instance of a Qobj class object.  This however is not very insightful, therefore we use the `print` command to get the relvant information about a quantum object:
{{{
print Qobj()
}}}
returning,
{{{
Quantum object: dims = [[1], [1]], shape = [1, 1]
Qobj data = 
[[0]]
}}}
where we now see the blank `Qobj` object dimensions, shape, and data.  Here the data corresponds to a 1x1-dimensional matrix consisting of a single zero entry.  We can create a `Qobj` with a user defined data set by passing a list or array of data into the `Qobj`:
{{{
print Qobj([1,2,3,4,5])

Quantum object: dims = [[1], [5]], shape = [1, 5]
Qobj data = 
[[1 2 3 4 5]]

x=array([[1],[2],[3],[4],[5]])
print Qobj(x)

Quantum object: dims = [[5], [1]], shape = [5, 1]
Qobj data = 
[[1]
 [2]
 [3]
 [4]
 [5]]

r=random((4,4))
print Qobj(r)

Quantum object: dims = [[4], [4]], shape = [4, 4]
Qobj data = 
[[ 0.76799998  0.06936066  0.10970546  0.13724402]
 [ 0.70644984  0.15371775  0.90649545  0.15349102]
 [ 0.69515726  0.13609801  0.52707457  0.6484309 ]
 [ 0.78328543  0.87295996  0.58964046  0.3998962 ]]

}}}
Notice how both the dims and shape change according to the input data.  Although dims and shape appear to have the same function, the difference will become quite clear in the section on tensor products and partial traces.


== States and operators ==
Now, unless you have lots of free time, specifying the data for each object is inefficient.  Even more so when most objects correspond to commonly used types such as the ladder operators of a harmonic oscillator,the Pauli spin operators for a two-level system, or state vectors such as Fock states.  Therefore, QuTiP includes predefined objects for a variety of states and operators.

|| *States* || *Command* (# means optional) || *Inputs*||
|| Fock state ket vector || basis(N,#m) / fock(N,#m) || N = number of levels in Hilbert space, m = level containing excitation (0 if no m given)  ||
|| Fock density matrix (outer product of basis) ||fock_dm(N,#p) || same as basis(N,m) / fock(N,m) ||
|| Coherent state || coherent(N,alpha) || alpha = complex number (eigenvalue) for requested coherent state ||
|| Coherent density matrix (outer product of coherent) || coherent_dm(N,alpha) || same as coherent(N,alpha) ||
|| Thermal density matrix (for n particles) || thermal_dm(N,n) || n = expectation value for number of particles ||


|| *Operators* || *Command* (# is optional) || *Inputs* ||
|| Identity || qeye(N) || N = number of levels in Hilbert space ||
|| Lowering (destruction) operator || destroy(N) || same as above   ||
|| Raising (creation) operator || create(N) || same as above  ||
|| Sigma-X || sigmax() || - ||
|| Sigma-Y || sigmay() || - ||
|| Sigma-Z || sigmaz() || - ||
|| Sigma plus || sigmap() || - ||
|| Sigma minus || sigmam() || - ||
|| Higher spin operators || jmat(j,d) || j = integer or half-integer representing spin, d = 'x', 'y', 'z', '+', or '-' ||

As an example, we give the output for a few of these objects:

{{{
print basis(5,3)

Quantum object: dims = [[5], [1]], shape = [5, 1]
Qobj data = 
[[ 0.]
 [ 0.]
 [ 0.]
 [ 1.]
 [ 0.]]

print coherent(5,0.5-0.5j)

Quantum object: dims = [[5], [1]], shape = [5, 1]
Qobj data = 
[[  7.78801702e-01 -5.63234865e-20j]
 [  3.89391417e-01 -3.89391417e-01j]
 [  7.59246032e-19 -2.75458952e-01j]
 [ -7.89861710e-02 -7.89861710e-02j]
 [ -4.31427083e-02 +3.46944695e-18j]]

print destroy(4)

Quantum object: dims = [[4], [4]], shape = [4, 4]
Qobj data = 
[[ 0.          1.          0.          0.        ]
 [ 0.          0.          1.41421356  0.        ]
 [ 0.          0.          0.          1.73205081]
 [ 0.          0.          0.          0.        ]]


print sigmaz()

Quantum object: dims = [[2], [2]], shape = [2, 2]
Qobj data = 
[[ 1.  0.]
 [ 0. -1.]]

print jmat(5/2.0,'+')

Quantum object: dims = [[6], [6]], shape = [6, 6]
Qobj data = 
[[ 0.          2.23606798  0.          0.          0.          0.        ]
 [ 0.          0.          2.82842712  0.          0.          0.        ]
 [ 0.          0.          0.          3.          0.          0.        ]
 [ 0.          0.          0.          0.          2.82842712  0.        ]
 [ 0.          0.          0.          0.          0.          2.23606798]
 [ 0.          0.          0.          0.          0.          0.        ]]

}}}

== Qobj attributes ==


== Qobj math ==


== Functions operating on Qobj class ==