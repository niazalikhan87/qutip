

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>An Overview of the Quantum Dynamics Solvers in QuTiP &mdash; QuTiP 1.1.2 documentation</title>
    
    <link rel="stylesheet" href="../_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/print.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.1.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/theme_extras.js"></script>
    <link rel="top" title="QuTiP 1.1.2 documentation" href="../index.html" />
    <link rel="up" title="QuTiP Users Guide" href="guide.html" />
    <link rel="next" title="Solving Two-Time Correlation Functions" href="guide-correlation.html" />
    <link rel="prev" title="Creating and Decomposing Composite Systems Using Tensor Products and Partial Traces" href="guide-tensor.html" /> 
  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="../index.html">
          <span>QuTiP 1.1.2 documentation</span></a></h1>
        <h2 class="heading"><span>An Overview of the Quantum Dynamics Solvers in QuTiP</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="guide-tensor.html">Creating and Decomposing Composite Systems Using Tensor Products and Partial Traces</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="guide-correlation.html">Solving Two-Time Correlation Functions</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="an-overview-of-the-quantum-dynamics-solvers-in-qutip">
<span id="guide-dynamics"></span><h1>An Overview of the Quantum Dynamics Solvers in QuTiP<a class="headerlink" href="#an-overview-of-the-quantum-dynamics-solvers-in-qutip" title="Permalink to this headline">¶</a></h1>
<div class="section" id="unitary-evolution">
<h2>Unitary evolution<a class="headerlink" href="#unitary-evolution" title="Permalink to this headline">¶</a></h2>
<p>The Schrödinger equation, which governs the time-evolution of closed quantum systems, is defined by its Hamiltonian and state vector. In the previous section, [GuideComposite Creating and manipulating composite objects with tensor and ptrace], we showed how Hamiltonians and state vectors are constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary (non-dissipative) time-evolution of an arbitrary state vector <em>psi0</em> using the QuTiP function :func:<a href="#id1"><span class="problematic" id="id2">`</span></a>qutip.odesolve`(H,rho0,tlist,c_op_list,expt_op_list,&amp;H_args,&amp;opt). It evolves the state vector and evaluates the expectation values for a set of operators <em>expt_op_list</em> at the points in time in the list <em>tlist</em>, using an ordinary differential equation solver. Alternatively, we can use the function :func:<a href="#id3"><span class="problematic" id="id4">`</span></a>essolve`(H,rho0,tlist,c_op_list,expt_op_list), which uses the exponential-series technique to calculate the time evolution of a system. The <em>odesolve</em> and <em>essolve</em> functions take the same arguments and it is therefore easy switch between the two solvers.</p>
<p>For example, the time evolution of a quantum spin-1/2 system with tunneling rate 0.1 that initially is in the up state is calculated, and the  expectation values of the sigma-Z operator evaluated, with the following code:</p>
<div class="highlight-python"><pre>&gt;&gt; H = 2 * pi * 0.1 * sigmax()
&gt;&gt; psi0 = basis(2, 0)
&gt;&gt; tlist = linspace(0.0, 10.0, 20.0)
&gt;&gt; odesolve(H, psi0, tlist, [], [sigmaz()])
array([[ 1.00000000+0.j,  0.78914229+0.j,  0.24548596+0.j, -0.40169696+0.j,
        -0.87947669+0.j, -0.98636356+0.j, -0.67728166+0.j, -0.08257676+0.j,
         0.54695235+0.j,  0.94582040+0.j,  0.94581706+0.j,  0.54694422+0.j,
        -0.08258520+0.j, -0.67728673+0.j, -0.98636329+0.j, -0.87947111+0.j,
        -0.40168898+0.j,  0.24549302+0.j,  0.78914528+0.j,  0.99999927+0.j]])</pre>
</div>
<p>The brackets in the fourth argument is an empty list of collapse operators,  since we consider unitary evolution in this example. See the next section for examples on how dissipation is included by defining a list of collapse operators.</p>
<p>The function returns an array of expectation values for the operators that are included in the list in the fifth argument. Adding operators to this list results in a larger output array returned by the function (one list of numbers, corresponding to the times in tlist, for each operator):</p>
<div class="highlight-python"><pre>&gt;&gt; odesolve(H, psi0, tlist, [], [sigmaz(), sigmay()])
array([[  1.00000000e+00+0.j,   7.89142292e-01+0.j,   2.45485961e-01+0.j,
         -4.01696962e-01+0.j,  -8.79476686e-01+0.j,  -9.86363558e-01+0.j,
         -6.77281655e-01+0.j,  -8.25767574e-02+0.j,   5.46952346e-01+0.j,
          9.45820404e-01+0.j,   9.45817056e-01+0.j,   5.46944216e-01+0.j,
         -8.25852032e-02+0.j,  -6.77286734e-01+0.j,  -9.86363287e-01+0.j,
         -8.79471112e-01+0.j,  -4.01688979e-01+0.j,   2.45493023e-01+0.j,
          7.89145284e-01+0.j,   9.99999271e-01+0.j],
       [  0.00000000e+00+0.j,  -6.14214010e-01+0.j,  -9.69403055e-01+0.j,
         -9.15775807e-01+0.j,  -4.75947716e-01+0.j,   1.64596791e-01+0.j,
          7.35726839e-01+0.j,   9.96586861e-01+0.j,   8.37166184e-01+0.j,
          3.24695883e-01+0.j,  -3.24704840e-01+0.j,  -8.37170685e-01+0.j,
         -9.96585195e-01+0.j,  -7.35720619e-01+0.j,  -1.64588257e-01+0.j,
          4.75953748e-01+0.j,   9.15776736e-01+0.j,   9.69398541e-01+0.j,
          6.14206262e-01+0.j,  -8.13905967e-06+0.j]])</pre>
</div>
<p>The resulting list of expectation values can easily be visualized using matplotlib&#8217;s plotting functions:</p>
<div class="highlight-python"><pre>&gt;&gt; tlist = linspace(0.0, 10.0, 100)
&gt;&gt; expt_list = odesolve(H, psi0, tlist, [], [sigmaz(), sigmay()])
&gt;&gt;
&gt;&gt; from pylab import *
&gt;&gt; plot(tlist, real(expt_list[0]))
&gt;&gt; plot(tlist, real(expt_list[1]))
&gt;&gt; xlabel('Time')
&gt;&gt; ylabel('Expectation values')
&gt;&gt; legend(("Simga-Z", "Sigma-Y"))
&gt;&gt; show()</pre>
</div>
<div class="figure align-center">
<img alt="http://qutip.googlecode.com/svn/wiki/images/guide-qubit-dynamics.png" src="http://qutip.googlecode.com/svn/wiki/images/guide-qubit-dynamics.png" />
</div>
<p>If an empty list of operators is passed as fifth parameter, the <em>odesolve</em> function returns a list of state vectors for the times specified in <em>tlist</em>:</p>
<div class="highlight-python"><pre>&gt;&gt; tlist = [0.0, 1.0]
&gt;&gt; odesolve(H, psi0, tlist, [], [])
[
Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket
Qobj data =
[[ 1.+0.j]
 [ 0.+0.j]]
, Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket
Qobj data =
[[ 0.80901765+0.j        ]
 [ 0.00000000-0.58778584j]]
, Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket
Qobj data =
[[ 0.3090168+0.j        ]
 [ 0.0000000-0.95105751j]]
, Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket
Qobj data =
[[-0.30901806+0.j        ]
 [ 0.00000000-0.95105684j]]
]</pre>
</div>
</div>
<div class="section" id="non-unitary-evolution">
<h2>Non-unitary evolution<a class="headerlink" href="#non-unitary-evolution" title="Permalink to this headline">¶</a></h2>
<div class="section" id="master-equation">
<h3>Master equation<a class="headerlink" href="#master-equation" title="Permalink to this headline">¶</a></h3>
<p>For non-unitary evolution of a quantum systems, i.e., evolution that includes
incoherent processes such as relaxation and dephasing, it is common to use
master equations. In QuTiP, the same function (<em>odesolve</em>) is used for
evolution both according to the Schrödinger equation and to the master equation,
even though these two equations of motion are very different. The <em>odesolve</em>
function automatically determines if it is sufficient to use the Schrödinger
equation (if no collapse operators were given) or if it has to use the
master equation (if collapse operators were given). Note that to calculate
the time evolution according to the Schrödinger equation is easier and much
faster (for large systems) than using the master equation, so if possible the
solver will fall back on using the Schrödinger equation.</p>
<p>What is new in the master equation compared to the Schrödinger equation are
processes that describe dissipation in the quantum system due to its interaction
with an environment. These environmental interactions are defined by the
operators through which the system couples to the environment, and rates that
describe the strength of the processes.</p>
<p>In QuTiP, the product of the square root of the rate and the operator that
describe the dissipation process is called a collapse operator. A list of
collapse operators (<em>c_op_list</em>) is passed as the fourth argument to the
<em>odesolve</em> function in order to define the dissipation processes in the master
eqaution. When the <em>c_op_list</em> isn&#8217;t empty, the <em>odesolve</em> function will use
the master equation instead of the unitary Schröderinger equation.</p>
<p>Using the example with the spin dynamics from the previous section, we can
easily add a relaxation process (describing the dissipation of energy from the
spin to its environment), by adding <cite>sqrt(0.05) * sigmax()</cite> to
the previously empty list in the fourth parameter to the <em>odesolve</em> function:</p>
<div class="highlight-python"><pre>&gt;&gt; tlist = linspace(0.0, 10.0, 100)
&gt;&gt; expt_list = odesolve(H, psi0, tlist, [sqrt(0.05) * sigmax()], [sigmaz(), sigmay()])
&gt;&gt;
&gt;&gt; from pylab import *
&gt;&gt; plot(tlist, real(expt_list[0]))
&gt;&gt; plot(tlist, real(expt_list[1]))
&gt;&gt; xlabel('Time')
&gt;&gt; ylabel('Expectation values')
&gt;&gt; legend(("Sigma-Z", "Sigma-Y"))
&gt;&gt; show()</pre>
</div>
<p>Here, <cite>0.05</cite> is the rate and the operator <cite>sigmax()</cite> describes the dissipation
process.</p>
<div class="figure align-center">
<img alt="http://qutip.googlecode.com/svn/wiki/images/guide-qubit-dynamics-dissip.png" src="http://qutip.googlecode.com/svn/wiki/images/guide-qubit-dynamics-dissip.png" />
</div>
<p>Now a slightly more complex example: Consider a two-level atom coupled to a leaky single-mode cavity through a dipole-type interaction, which supports a coherent exchange of quanta between the two systems. If the atom initially is in its groundstate and the cavity in a 5-photon fock state, the dynamics is calculated with the lines following code:</p>
<div class="highlight-python"><pre>&gt;&gt; tlist = linspace(0.0, 10.0, 200)
&gt;&gt; psi0 = tensor(fock(2,0), fock(10, 5))
&gt;&gt; a  = tensor(qeye(2), destroy(10))
&gt;&gt; sm = tensor(destroy(2), qeye(10))
&gt;&gt; H = 2*pi * a.dag() * a + 2 * pi * sm.dag() * sm + 2*pi * 0.25 * (sm*a.dag() + sm.dag() * a)
&gt;&gt; expt_list = odesolve(H, psi0, tlist, ntraj, [sqrt(0.1)*a], [a.dag()*a, sm.dag()*sm])
&gt;&gt;
&gt;&gt; from pylab import *
&gt;&gt; plot(tlist, real(expt_list[0]))
&gt;&gt; plot(tlist, real(expt_list[1]))
&gt;&gt; xlabel('Time')
&gt;&gt; ylabel('Expectation values')
&gt;&gt; legend(("cavity photon number", "atom excitation probability"))
&gt;&gt; show()</pre>
</div>
<div class="figure align-center">
<img alt="http://qutip.googlecode.com/svn/wiki/images/guide-jc-dynamics.png" src="http://qutip.googlecode.com/svn/wiki/images/guide-jc-dynamics.png" />
</div>
</div>
<div class="section" id="monte-carlo-evolution">
<h3>Monte-Carlo evolution<a class="headerlink" href="#monte-carlo-evolution" title="Permalink to this headline">¶</a></h3>
<p>Quantum trajectory Monte-Carlo is an alternative approach for calculating the
time-evolution of dissipative quantum systems. Unlike the master equation,
the Monte-Carlo method is based on the unitary evolution and uses the state
vector instead of density matrix to describe the state of the system.
Dissipation is introduced into the dynamics by stochastic quantum jumps,
whose rate and effect on the state of the system is described by the same
collapse operators that are used to define the master equation. The average of
a large number of such stochastic trajectories describes the dissipative
dynamics of the system, and has been shown to give identical results as the
master equation.</p>
<p>In QuTiP, Monto-Carlo evolution is implemented with the
<em>[Functions#mcsolve(H,psi0,tlist,ntraj,collapse_ops,expect_ops,&amp;H_args,&amp;options=Odeoptions()) mcsolve]</em> function. It takes nearly the same arguments as the <em>odesolve</em>
function for master-equation evolution, expect for one additional parameter
<cite>ntraj</cite> (fourth parameter), which define the number of stochastic trajectories
that should be averaged. This number should usually be in the range 100 - 500 to
give a smooth results (although the optimal number for <cite>ntraj</cite> can vary from
case to case).</p>
<p>To illustrate the use of the Monte-Carlo evolution of quantum systems in QuTiP,
let&#8217;s again consider the case of a two-level atom coupled to a leaky cavity. The
only differences to the master-equation treatment is that in this case we
invoke the <em>[Functions#mcsolve(H,psi0,tlist,ntraj,collapse_ops,expect_ops,&amp;H_args,&amp;options=Odeoptions()) mcsolve]</em> function instead of <em>odesolve</em>, and a new parameter
<cite>ntraj = 250</cite> has been defined:</p>
<div class="highlight-python"><pre>&gt;&gt; tlist = linspace(0.0, 10.0, 200)
&gt;&gt; psi0 = tensor(fock(2,0), fock(10, 5))
&gt;&gt; a  = tensor(qeye(2), destroy(10))
&gt;&gt; sm = tensor(destroy(2), qeye(10))
&gt;&gt; H = 2*pi * a.dag() * a + 2 * pi * sm.dag() * sm + 2*pi * 0.25 * (sm*a.dag() + sm.dag() * a)
&gt;&gt; ntraj = 250
&gt;&gt; expt_list = mcsolve(H, psi0, tlist, ntraj, [sqrt(0.1)*a], [a.dag()*a, sm.dag()*sm])
&gt;&gt;
&gt;&gt; from pylab import *
&gt;&gt; plot(tlist, real(expt_list[0]))
&gt;&gt; plot(tlist, real(expt_list[1]))
&gt;&gt; title('Monte-Carlo time evolution')
&gt;&gt; xlabel('Time')
&gt;&gt; ylabel('Expectation values')
&gt;&gt; legend(("cavity photon number", "atom excitation probability"))
&gt;&gt; show()</pre>
</div>
<div class="figure align-center">
<img alt="http://qutip.googlecode.com/svn/wiki/images/guide-mc-dynamics.png" src="http://qutip.googlecode.com/svn/wiki/images/guide-mc-dynamics.png" />
</div>
<p>The advantage of the Monte-Carlo method over the master equation approach is that
only the state vector is required to be kept in the computer memory (as opposed to
the entire density matrix). For large quantum system this becomes a significant
advantage and the Monte-Carlo is therefore generally recommended for such systems.
But for small systems, on the other hand, the added overhead of averaging a large number of stochastic trajectories to obtain the open system dynamics outweigh the benefits of the (small) memory saving,
and master equations are therefore generally more efficient.</p>
<p>The return value(s) from the Monte-Carlo solver depend on the presence of collapse and expectation operators in the <cite>mcsolve</cite> function, as well as how many outputs are requested by the user.  The last example had both collapse and expectation value operators:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">out</span><span class="o">=</span><span class="n">mcsolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">tlist</span><span class="p">,</span> <span class="n">ntraj</span><span class="p">,</span> <span class="p">[</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="p">],</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="n">sm</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">*</span><span class="n">sm</span><span class="p">])</span>
</pre></div>
</div>
<p>and the user requested a single output <cite>out</cite>.  In this case, the monte-carlo solver returns the average over all trajectories for the expectation values generated by the requested operators.  If we remove the collapse operators:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">out</span><span class="o">=</span><span class="n">mcsolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">tlist</span><span class="p">,</span> <span class="n">ntraj</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="n">sm</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">*</span><span class="n">sm</span><span class="p">])</span>
</pre></div>
</div>
<p>then we will also get expectation values for the output.  Now, if we add back in the collapse operators, but remove the expectation value operators:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">out</span><span class="o">=</span><span class="n">mcsolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">tlist</span><span class="p">,</span> <span class="n">ntraj</span><span class="p">,</span> <span class="p">[</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="p">],</span> <span class="p">[])</span>
</pre></div>
</div>
<p>then the output of <cite>mcsolve</cite> <em>is not</em> a list of expectation values but rather a list of state vector Qobjs calculated for each time, and trajectory.  This a huge output and should be avoided unless you want to see the jumps associated with the collapse operators for individual trajectories.  For example,:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>will be a list of state vector Qobjs evaluated at the times in <cite>tlist</cite>.</p>
<p>In addition, when collapse operators are specified, the monte-carlo solver will also keep track of when a collapse occurs, and which operator did the collapse.  To obtain this information, the user must specify multiple return values from the <cite>mcsolve</cite> function.  For example, to get the times at which collapses occurred for the trajectories we can do:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">expt</span><span class="p">,</span><span class="n">times</span><span class="o">=</span><span class="n">mcsolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">tlist</span><span class="p">,</span> <span class="n">ntraj</span><span class="p">,</span> <span class="p">[</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="p">],</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="n">sm</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">*</span><span class="n">sm</span><span class="p">])</span>
</pre></div>
</div>
<p>where we have requested a second output <cite>times</cite>.  Again the first operator corresponds to the expectation values.  To get the information on which operator did the collapse we add a third return value:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">expt</span><span class="p">,</span><span class="n">times</span><span class="p">,</span><span class="n">which</span><span class="o">=</span><span class="n">mcsolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">tlist</span><span class="p">,</span> <span class="n">ntraj</span><span class="p">,</span> <span class="p">[</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="p">],</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="n">sm</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">*</span><span class="n">sm</span><span class="p">])</span>
</pre></div>
</div>
<p>If no expectation values are specified then the first output will be a list of state vectors.  A example demonstrating the use of multiple return values may be found at <em>[ExamplesMCTimesWhich]</em>.  To summarize, the table below gives the output of the monte-carlo solver for a given set of inout and output conditions:</p>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="21%" />
<col width="27%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Collapse operators</th>
<th class="head">Expectation operators</th>
<th class="head">Number of requested outputs</th>
<th class="head">Return value(s)</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>NO</td>
<td>NO</td>
<td>1</td>
<td>List of state vectors</td>
</tr>
<tr class="row-odd"><td>NO</td>
<td>YES</td>
<td>1</td>
<td>List of expectation values</td>
</tr>
<tr class="row-even"><td>YES</td>
<td>NO</td>
<td>1</td>
<td>List of state vectors for each
trajectory.</td>
</tr>
<tr class="row-odd"><td>YES</td>
<td>NO</td>
<td>2</td>
<td>List of state vectors for each
trajectory + List of collapse times
for each trajectory.</td>
</tr>
<tr class="row-even"><td>YES</td>
<td>NO</td>
<td>3</td>
<td>List of state vectors for each
trajectory + List of collapse times
for each trajectory + List of which
operator did collapse for each
trajectory.</td>
</tr>
<tr class="row-odd"><td>YES</td>
<td>YES</td>
<td>1</td>
<td>List of expectation values for each
trajectory.</td>
</tr>
<tr class="row-even"><td>YES</td>
<td>YES</td>
<td>2</td>
<td>List of expectation values for each
trajectory + List of collapse times
for each trajectory.</td>
</tr>
<tr class="row-odd"><td>YES</td>
<td>YES</td>
<td>3</td>
<td>List of expectation values for each
trajectory + List of collapse times
for each trajectory + List of which
operator did collapse for each
trajectory.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="which-solver-should-i-use">
<h2>Which solver should I use?<a class="headerlink" href="#which-solver-should-i-use" title="Permalink to this headline">¶</a></h2>
<p>In general, the choice of solver is determined by the size of your system, as well as your desired output.  The computational resources required by the master equation solver scales as <cite>N**2</cite>, where N is the dimensionality of the Hilbert space.  For small systems, the master equation method is very efficient. In contrast, the monte-carlo solver scales as <cite>N</cite>, but requires running multiple trajectories to average over to get the desired expectation values.  Therefore, if your system is too large, and you run out of memory using <cite>odesolve</cite>, then the only option available will be <cite>mcsolve</cite>.  On the other hand, the monte-carlo method cannot return the full density matrix as a function of time and you need to use <cite>odesolve</cite> if this is required.</p>
<p>If your system is intermediate in size (you are not bound by memory) then it is interesting to calculate the crossover point where the monte-carlo solver begins to perform better than the master equation method.  The exact point at which one solver is better than the other will depend on the system of interest and number of processors. However as a guideline, below we have plotted the time required to solve for the evolution of coupled dissipative harmonic oscillators as a function of Hilbert space size.</p>
<div class="figure align-center">
<img alt="http://qutip.googlecode.com/svn/wiki/images/solver-performance.png" src="http://qutip.googlecode.com/svn/wiki/images/solver-performance.png" />
</div>
<p>Here, the number of trajectories used in <cite>mcsolve</cite> is <cite>250</cite> and the number of processors (which determines the slope of the monte-carlo line) is <cite>4</cite>.  Here we see that the monte-carlo solver begins to be more efficient than the corresponding master-equation method at a Hilbert space size of <cite>N~40</cite>.  Therefore, if your system size is greater than <cite>N~40</cite> and you do not need the full density matrix, then it is recommended to try the <cite>mcsolve</cite> function.</p>
</div>
<div class="section" id="time-dependent-hamiltonians-unitary-and-non-unitary">
<h2>Time-dependent Hamiltonians (unitary and non-unitary)<a class="headerlink" href="#time-dependent-hamiltonians-unitary-and-non-unitary" title="Permalink to this headline">¶</a></h2>
<p>In the previous examples of quantum system evolution, we assumed that
the systems under consideration were described by a time-independent
Hamiltonian. The two main evolution solvers in QuTiP, <em>odesolve</em> and
<em>mcsolve</em>, can also handle time-dependent Hamiltonians. If a callback function
is passed as first parameter to the solver function (instead of <em>Qobj</em>
Hamiltonian), then this function is called at each time step and is expected
to return the <em>Qobj</em> Hamiltonian for that point in time. The callback function
takes two arguments: the time <cite>t</cite> and list additional Hamiltonian arguments
<cite>H_args</cite>. This list of additional arguments is the same object as is passed
as the sixth parameter to the solver function (only used for time-dependent
Hamiltonians).</p>
<p>For example, let&#8217;s consider a two-level system with energy splitting 1.0, and
subject to a time-dependent field that couples to the Sigma-X operator with
amplitude 0.1. Furthermore, to make the example a little bit more interesting,
let&#8217;s also assume that the two-level system is subject to relaxation, with
relaxation rate 0.01. The following code calculates the dynamics of the system
in the absence and in the presence of the time-dependent driving signal:</p>
<div class="highlight-python"><pre>&gt;&gt; def hamiltonian_t(t, args):
&gt;&gt;     H0 = args[0]
&gt;&gt;     H1 = args[1]
&gt;&gt;     w  = args[2]
&gt;&gt;     return H0 + H1 * sin(w * t)
&gt;&gt;
&gt;&gt; H0 = - 2*pi * 0.5  * sigmaz()
&gt;&gt; H1 = - 2*pi * 0.05 * sigmax()
&gt;&gt; H_args = (H0, H1, 2*pi*1.0)
&gt;&gt; psi0 = fock(2, 0)                   # intial state |0&gt;
&gt;&gt; c_op_list = [sqrt(0.01) * sigmam()] # relaxation
&gt;&gt; tlist = arange(0.0, 50.0, 0.01)
&gt;&gt;
&gt;&gt; expt_sz    = odesolve(H0, psi0, tlist, c_op_list, [sigmaz()])
&gt;&gt; expt_sz_td = odesolve(hamiltonian_t, psi0, tlist, c_op_list, [sigmaz()], H_args)
&gt;&gt;
&gt;&gt; #expt_sz_td = mcsolve(hamiltonian_t, psi0, tlist,250, c_op_list, [sigmaz()], H_args) #monte-carlo
&gt;&gt;
&gt;&gt; from pylab import *
&gt;&gt; plot(tlist, expt_sz[0],    'r')
&gt;&gt; plot(tlist, expt_sz_td[0], 'b')
&gt;&gt; ylabel("Expectation value of Sigma-Z")
&gt;&gt; xlabel("time")
&gt;&gt; legend(("H = H0", "H = H0 + H1 * sin(w*t)"), loc=4)
&gt;&gt; show()</pre>
</div>
<div class="figure align-center">
<img alt="http://qutip.googlecode.com/svn/wiki/images/guide-td-dynamics.png" src="http://qutip.googlecode.com/svn/wiki/images/guide-td-dynamics.png" />
</div>
</div>
<div class="section" id="setting-ode-solver-options">
<h2>Setting ODE solver options<a class="headerlink" href="#setting-ode-solver-options" title="Permalink to this headline">¶</a></h2>
<p>Occasionally it is necessary to change the built in parameters of the ODE solvers used by both the odesolve and mcsolve functions.  The ODE options for either of these functions may be changed by calling the Odeoptions class:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">opts</span><span class="o">=</span><span class="n">Odeoptions</span><span class="p">()</span>
</pre></div>
</div>
<p>the properties and default values of this class can be view via the <cite>print</cite> command:</p>
<div class="highlight-python"><pre>print opts

Odeoptions properties:
----------------------
atol:        1e-10
rtol:        1e-08
method:      adams
order:       12
nsteps:      1000
first_step:  0
min_step:    0
max_step:    0</pre>
</div>
<p>These properties are detailed in the following table.  Assuming <a href="#id5"><span class="problematic" id="id6">`</span></a>opts=Odeoptions()&#8217;:</p>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="17%" />
<col width="65%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Property</th>
<th class="head">Default setting</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>opts.atol</td>
<td>1e-10</td>
<td>Absolute tolerance</td>
</tr>
<tr class="row-odd"><td>opts.rtol</td>
<td>1e-08</td>
<td>Relative tolerance</td>
</tr>
<tr class="row-even"><td>opts.method</td>
<td>&#8216;adams&#8217;</td>
<td>Solver method.  Can be &#8216;adams&#8217; (non-stiff) or &#8216;bdf&#8217; (stiff)</td>
</tr>
<tr class="row-odd"><td>opts.order</td>
<td>12</td>
<td>Order of solver.  Must be &lt;=12 for &#8216;adams&#8217; and &lt;=5 for &#8216;bdf&#8217;</td>
</tr>
<tr class="row-even"><td>opts.nsteps</td>
<td>1000</td>
<td>Max. number of steps to take for each interval</td>
</tr>
<tr class="row-odd"><td>opts.first_step</td>
<td>0</td>
<td>Size of initial step.  0 = determined automatically by solver.</td>
</tr>
<tr class="row-even"><td>opts.min_step</td>
<td>0</td>
<td>Minimum step size.  0 = determined automatically by solver.</td>
</tr>
<tr class="row-odd"><td>opts.max_step</td>
<td>0</td>
<td>Maximum step size.  0 = determined automatically by solver.</td>
</tr>
</tbody>
</table>
<p>As an example, let us consider relaxing the conditions on the ODE solver:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">opts</span><span class="o">.</span><span class="n">atol</span><span class="o">=</span><span class="mf">1e-8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">opts</span><span class="o">.</span><span class="n">rtol</span><span class="o">=</span><span class="mf">1e-6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">opts</span><span class="o">.</span><span class="n">nsteps</span><span class="o">=</span><span class="mi">500</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">opts</span>

<span class="go">Odeoptions properties:</span>
<span class="go">----------------------</span>
<span class="go">atol:        1e-08</span>
<span class="go">rtol:        1e-06</span>
<span class="go">method:      adams</span>
<span class="go">order:       12</span>
<span class="go">nsteps:      500</span>
<span class="go">first_step:  0</span>
<span class="go">min_step:    0</span>
<span class="go">max_step:    0</span>
</pre></div>
</div>
<p>To use these new settings we can use the keyword argument <cite>options</cite> in either the <cite>odesolve</cite> or <cite>mcsolve</cite> function.  We can modify the last example as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">odesolve</span><span class="p">(</span><span class="n">H0</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">tlist</span><span class="p">,</span> <span class="n">c_op_list</span><span class="p">,</span> <span class="p">[</span><span class="n">sigmaz</span><span class="p">()],</span><span class="n">options</span><span class="o">=</span><span class="n">opts</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">odesolve</span><span class="p">(</span><span class="n">hamiltonian_t</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">tlist</span><span class="p">,</span> <span class="n">c_op_list</span><span class="p">,</span> <span class="p">[</span><span class="n">sigmaz</span><span class="p">()],</span> <span class="n">H_args</span><span class="p">,</span><span class="n">options</span><span class="o">=</span><span class="n">opts</span><span class="p">)</span>
</pre></div>
</div>
<p>or:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mcsolve</span><span class="p">(</span><span class="n">H0</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">tlist</span><span class="p">,</span> <span class="n">ntraj</span><span class="p">,</span><span class="n">c_op_list</span><span class="p">,</span> <span class="p">[</span><span class="n">sigmaz</span><span class="p">()],</span><span class="n">options</span><span class="o">=</span><span class="n">opts</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mcsolve</span><span class="p">(</span><span class="n">hamiltonian_t</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">tlist</span><span class="p">,</span> <span class="n">ntraj</span><span class="p">,</span> <span class="n">c_op_list</span><span class="p">,</span> <span class="p">[</span><span class="n">sigmaz</span><span class="p">()],</span> <span class="n">H_args</span><span class="p">,</span><span class="n">options</span><span class="o">=</span><span class="n">opts</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="performance-version-1-1-1">
<h2>Performance (version 1.1.1)<a class="headerlink" href="#performance-version-1-1-1" title="Permalink to this headline">¶</a></h2>
<p>Here we compare the performance of the master-equation and monte-Carlo solvers to their quantum optics toolbox counterparts.</p>
<p>In this example, we calculate the time-evolution of the density matrix for a coupled oscillator system using the odesolve function, and compare it to the quantum optics toolbox (qotoolbox).  Here, we see that the QuTiP solver out performs it&#8217;s qotoolbox counterpart by a substantial margin as the system size increases.</p>
<div class="figure align-center">
<img alt="http://qutip.googlecode.com/svn/wiki/images/odesolve_performance.png" src="http://qutip.googlecode.com/svn/wiki/images/odesolve_performance.png" />
</div>
<p>To test the monte-carlo solvers, here we simulate a trilinear Hamiltonian over a range of Hilbert space sizes.  Since QuTiP uses multiprocessing, we can measure the performance gain when using several CPU&#8217;s.  In contrast, the qotoolbox is limited to a single-processor only.  In the legend, we show the speed-up factor in the parenthesis, which should ideally be equal to the number of processors.  Finally, we have included the results using hyperthreading, written here as 4+(x) where x is the number of hyperthreads, found in some newer Intel processors.  We see however that the performance benefit is marginal at best.</p>
<div class="figure align-center">
<img alt="http://qutip.googlecode.com/svn/wiki/images/mcsolve_performance.png" src="http://qutip.googlecode.com/svn/wiki/images/mcsolve_performance.png" />
</div>
</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="guide-tensor.html">Creating and Decomposing Composite Systems Using Tensor Products and Partial Traces</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="guide-correlation.html">Solving Two-Time Correlation Functions</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer">
        &copy; Copyright 2011, P.D. Nation, J.R. Johansson.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.
    </div>
  </body>
</html>