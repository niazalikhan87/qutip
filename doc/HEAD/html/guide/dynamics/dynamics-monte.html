

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Quantum Dynamics via the Monte-Carlo Solver &mdash; QuTiP: The Quantum Toolbox in Python 2.0 documentation</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '2.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="top" title="QuTiP: The Quantum Toolbox in Python 2.0 documentation" href="../../index.html" />
    <link rel="up" title="Evaluating Quantum System Dynamics" href="../guide-dynamics.html" />
    <link rel="next" title="Bloch-Redfield master equation" href="dynamics-bloch-redfield.html" />
    <link rel="prev" title="Lindblad Master Equation Solver" href="dynamics-master.html" /> 
  </head>
  <body>

<div style="background-color: #EBEBEB; text-align: left; padding: 0px 0px 15px 15px">
<a href="../../index.html"><img src="../../_static/logo.png" border="0" alt="qutip"/></a>
</div>


    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="dynamics-bloch-redfield.html" title="Bloch-Redfield master equation"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="dynamics-master.html" title="Lindblad Master Equation Solver"
             accesskey="P">previous</a> |</li>
        <li><a href="../../index.html">home</a>|&nbsp;</li>
        <li><a href="../../search.html">search</a>|&nbsp;</li>

          <li><a href="../guide.html" >QuTiP Users Guide</a> &raquo;</li>
          <li><a href="../guide-dynamics.html" accesskey="U">Evaluating Quantum System Dynamics</a> &raquo;</li> 
      </ul>
    </div>

      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Quantum Dynamics via the Monte-Carlo Solver</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#monte-carlo-in-qutip">Monte-Carlo in QuTiP:</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="dynamics-master.html"
                        title="previous chapter">Lindblad Master Equation Solver</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="dynamics-bloch-redfield.html"
                        title="next chapter">Bloch-Redfield master equation</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../../_sources/guide/dynamics/dynamics-monte.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="quantum-dynamics-via-the-monte-carlo-solver">
<span id="monte"></span><h1>Quantum Dynamics via the Monte-Carlo Solver<a class="headerlink" href="#quantum-dynamics-via-the-monte-carlo-solver" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<span id="monte-intro"></span><h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>Where as the density matrix formalism describes the ensemble average over many identical realizations of a quantum system, the Monte-Carlo (MC), or quantum-jump approach to wave function evolution, allows for simulating an individual realization of the system dynamics.  Here, the environment is continuously monitored, resulting in a series of quantum jumps in the system wave function, conditioned on the increase in information gained about the state of the system via the environmental measurements.  In general, this evolution is governed by the Schrödinger equation (<a href="#equation-schrodinger">(?)</a>) with a <strong>non-Hermitian</strong> effective Hamiltonian</p>
<div class="math" id="equation-heff">
<span class="eqno">(1)</span>\[H_{\rm eff}=H_{\rm sys}-\frac{i\hbar}{2}\sum_{i}C^{+}_{n}C_{n},\]</div>
<p>where again, the <span class="math">\(C_{n}\)</span> are collapse operators, each corresponding to a separate irreversible process with rate <span class="math">\(\gamma_{n}\)</span>.  Here, the strictly negative non-Hermitian portion of Eq.~(<a href="#equation-heff">(1)</a>) gives rise to a reduction in the norm of the wave function, that to first-order in a small time <span class="math">\(\delta t\)</span>, is given by <span class="math">\(\left&lt;\psi(t+\delta t)|\psi(t+\delta t)\right&gt;=1-\delta p\)</span> where</p>
<div class="math" id="equation-jump">
<span class="eqno">(2)</span>\[\begin{split}\delta p =\delta t \sum_{n}\left&lt;\psi(t)|C^{+}_{n}C_{n}|\psi(t)\right&gt;,\end{split}\]</div>
<p>and <span class="math">\(\delta t\)</span> is such that <span class="math">\(\delta p \ll 1\)</span>.  With a probability of remaining in the state <span class="math">\(\left|\psi(t+\delta t)\right&gt;\)</span> given by <span class="math">\(1-\delta p\)</span>, the corresponding quantum jump probability is thus Eq.~(<a href="#equation-jump">(2)</a>).  If the environmental measurements register a quantum jump, say via the emission of a photon into the environment, or a change in the spin of a quantum dot, the wave function undergoes a jump into a state defined by projecting <span class="math">\(\left|\psi(t)\right&gt;\)</span> using the collapse operator <span class="math">\(C_{n}\)</span> corresponding to the measurement</p>
<div class="math" id="equation-project">
<span class="eqno">(3)</span>\[\begin{split}\left|\psi(t+\delta t)\right&gt;=C_{n}\left|\psi(t)\right&gt;/\left&lt;\psi(t)|C_{n}^{+}C_{n}|\psi(t)\right&gt;^{1/2}.\end{split}\]</div>
<p>If more than a single collapse operator is present in Eq~(<a href="#equation-heff">(1)</a>), the probability of collapse due to the <span class="math">\(i\mathrm{th}$-operator $C_{i}\)</span> is given by</p>
<div class="math" id="equation-pcn">
<span class="eqno">(4)</span>\[\begin{split}P_{i}(t)=\left&lt;\psi(t)|C_{i}^{+}C_{i}|\psi(t)\right&gt;/\delta p.\end{split}\]</div>
<p>Evaluating the MC evolution to first-order in time is quite tedious.  Instead, QuTiP uses the following algorithm to simulate a single realization of a quantum system.  Starting from a pure state <span class="math">\(\left|\psi(0)\right&gt;\)</span>:</p>
<ul class="simple">
<li><strong>I:</strong> Choose a random number <span class="math">\(r\)</span> between zero and one, representing the probability that a quantum jump occurs.</li>
<li><strong>II:</strong> Integrate the Schrödinger equation (<a href="#equation-schrodinger">(?)</a>), using the effective Hamiltonian (<a href="#equation-heff">(1)</a>) until a time <span class="math">\(\tau\)</span> such that the norm of the wave function satisfies <span class="math">\(\left&lt;\psi(\tau)\right.\left|\psi(\tau)\right&gt;=r\)</span>, at which point a jump occurs.</li>
<li><strong>III:</strong> The resultant jump projects the system at time <span class="math">\(\tau\)</span> into one of the renormalized states given by Eq.~(<a href="#equation-project">(3)</a>).  The corresponding collapse operator <span class="math">\(C_{n}\)</span> is chosen such that <span class="math">\(n\)</span> is the smallest integer satisfying:</li>
</ul>
<div class="math" id="equation-mc3">
<span class="eqno">(5)</span>\[\sum_{i=1}^{n} P_{n}(\tau) \ge r\]</div>
<p>where the individual <span class="math">\(P_{n}\)</span> are given by Eq.~(<a href="#equation-pcn">(4)</a>).  Note that the left hand side of Eq.~(<a href="#equation-mc3">(5)</a>) is, by definition, normalized to unity.</p>
<ul class="simple">
<li><strong>IV:</strong> Using the renormalized state from step III as the new initial condition at time <span class="math">\(\tau\)</span>, draw a new random number, and repeat the above procedure until the final simulation time is reached.</li>
</ul>
</div>
<div class="section" id="monte-carlo-in-qutip">
<span id="monte-qutip"></span><h2>Monte-Carlo in QuTiP:<a class="headerlink" href="#monte-carlo-in-qutip" title="Permalink to this headline">¶</a></h2>
<p>In QuTiP, Monto-Carlo evolution is implemented with the
<a class="reference internal" href="../../apidoc/functions.html#module-qutip.mcsolve" title="qutip.mcsolve"><tt class="xref py py-func docutils literal"><span class="pre">qutip.mcsolve</span></tt></a> function. It takes nearly the same arguments as the <a class="reference internal" href="../../apidoc/functions.html#module-qutip.mesolve" title="qutip.mesolve"><tt class="xref py py-func docutils literal"><span class="pre">qutip.mesolve</span></tt></a>
function for master-equation evolution, expect for one additional parameter
<tt class="docutils literal"><span class="pre">ntraj</span></tt> (fourth parameter), which define the number of stochastic trajectories
that should be averaged. This number should usually be in the range 100 - 500 to
give a smooth results (although the optimal number for <tt class="docutils literal"><span class="pre">ntraj</span></tt> can vary from
case to case).</p>
<p>To illustrate the use of the Monte-Carlo evolution of quantum systems in QuTiP,
let&#8217;s again consider the case of a two-level atom coupled to a leaky cavity. The
only differences to the master-equation treatment is that in this case we
invoke the <a class="reference internal" href="../../apidoc/functions.html#module-qutip.mcsolve" title="qutip.mcsolve"><tt class="xref py py-func docutils literal"><span class="pre">qutip.mcsolve</span></tt></a> function instead of <a class="reference internal" href="../../apidoc/functions.html#module-qutip.mesolve" title="qutip.mesolve"><tt class="xref py py-func docutils literal"><span class="pre">qutip.mesolve</span></tt></a>, and a new parameter
<tt class="docutils literal"><span class="pre">ntraj</span> <span class="pre">=</span> <span class="pre">250</span></tt> has been defined:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">tlist</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">psi0</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">(</span><span class="n">fock</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">fock</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  <span class="o">=</span> <span class="n">tensor</span><span class="p">(</span><span class="n">qeye</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">destroy</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sm</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">(</span><span class="n">destroy</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">qeye</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span> <span class="o">*</span> <span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">sm</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">sm</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">0.25</span> <span class="o">*</span> <span class="p">(</span><span class="n">sm</span><span class="o">*</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">+</span> <span class="n">sm</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ntraj</span> <span class="o">=</span> <span class="mi">250</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expt_list</span> <span class="o">=</span> <span class="n">mcsolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">tlist</span><span class="p">,</span> <span class="n">ntraj</span><span class="p">,</span> <span class="p">[</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="p">],</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="n">sm</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">*</span><span class="n">sm</span><span class="p">])</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pylab</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="p">(</span><span class="n">tlist</span><span class="p">,</span> <span class="n">real</span><span class="p">(</span><span class="n">expt_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="p">(</span><span class="n">tlist</span><span class="p">,</span> <span class="n">real</span><span class="p">(</span><span class="n">expt_list</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">title</span><span class="p">(</span><span class="s">&#39;Monte-Carlo time evolution&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;Time&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;Expectation values&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">legend</span><span class="p">((</span><span class="s">&quot;cavity photon number&quot;</span><span class="p">,</span> <span class="s">&quot;atom excitation probability&quot;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<div class="figure align-center">
<img alt="../../_images/guide-dynamics-mc.png" src="../../_images/guide-dynamics-mc.png" style="width: 4in;" />
</div>
<p>The advantage of the Monte-Carlo method over the master equation approach is that only the state vector is required to be kept in the computer memory (as opposed to the entire density matrix). For large quantum system this becomes a significant advantage and the Monte-Carlo is therefore generally recommended for such systems. But for small systems, on the other hand, the added overhead of averaging a large number of stochastic trajectories to obtain the open system dynamics outweigh the benefits of the (small) memory saving, and master equations are therefore generally more efficient.</p>
<p>The return value(s) from the Monte-Carlo solver depend on the presence of collapse and expectation operators in the <a class="reference internal" href="../../apidoc/functions.html#module-qutip.mcsolve" title="qutip.mcsolve"><tt class="xref py py-func docutils literal"><span class="pre">qutip.mcsolve</span></tt></a> function, as well as how many outputs are requested by the user.  The last example had both collapse and expectation value operators:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">out</span><span class="o">=</span><span class="n">mcsolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">tlist</span><span class="p">,</span> <span class="n">ntraj</span><span class="p">,</span> <span class="p">[</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="p">],</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="n">sm</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">*</span><span class="n">sm</span><span class="p">])</span>
</pre></div>
</div>
<p>and the user requested a single output <tt class="docutils literal"><span class="pre">out</span></tt>.  In this case, the monte-carlo solver returns the average over all trajectories for the expectation values generated by the requested operators.  If we remove the collapse operators:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">out</span><span class="o">=</span><span class="n">mcsolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">tlist</span><span class="p">,</span> <span class="n">ntraj</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="n">sm</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">*</span><span class="n">sm</span><span class="p">])</span>
</pre></div>
</div>
<p>then we will also get expectation values for the output.  Now, if we add back in the collapse operators, but remove the expectation value operators:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">out</span><span class="o">=</span><span class="n">mcsolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">tlist</span><span class="p">,</span> <span class="n">ntraj</span><span class="p">,</span> <span class="p">[</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="p">],</span> <span class="p">[])</span>
</pre></div>
</div>
<p>then the output of <a class="reference internal" href="../../apidoc/functions.html#module-qutip.mcsolve" title="qutip.mcsolve"><tt class="xref py py-func docutils literal"><span class="pre">qutip.mcsolve</span></tt></a> <em>is not</em> a list of expectation values but rather a list of state vector Qobjs calculated for each time, and trajectory.  This a huge output and should be avoided unless you want to see the jumps associated with the collapse operators for individual trajectories.  For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>will be a list of state vector Qobjs evaluated at the times in <tt class="docutils literal"><span class="pre">tlist</span></tt>.</p>
<p>In addition, when collapse operators are specified, the monte-carlo solver will also keep track of when a collapse occurs, and which operator did the collapse.  To obtain this information, the user must specify multiple return values from the <a class="reference internal" href="../../apidoc/functions.html#module-qutip.mcsolve" title="qutip.mcsolve"><tt class="xref py py-func docutils literal"><span class="pre">qutip.mcsolve</span></tt></a> function.  For example, to get the times at which collapses occurred for the trajectories we can do:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">expt</span><span class="p">,</span><span class="n">times</span><span class="o">=</span><span class="n">mcsolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">tlist</span><span class="p">,</span> <span class="n">ntraj</span><span class="p">,</span> <span class="p">[</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="p">],</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="n">sm</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">*</span><span class="n">sm</span><span class="p">])</span>
</pre></div>
</div>
<p>where we have requested a second output <cite>times</cite>.  Again the first operator corresponds to the expectation values.  To get the information on which operator did the collapse we add a third return value:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">expt</span><span class="p">,</span><span class="n">times</span><span class="p">,</span><span class="n">which</span><span class="o">=</span><span class="n">mcsolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">tlist</span><span class="p">,</span> <span class="n">ntraj</span><span class="p">,</span> <span class="p">[</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="p">],</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="n">sm</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">*</span><span class="n">sm</span><span class="p">])</span>
</pre></div>
</div>
<p>If no expectation values are specified then the first output will be a list of state vectors.  A example demonstrating the use of multiple return values may be found at .  To summarize, the table below gives the output of the monte-carlo solver for a given set of input and output conditions:</p>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="21%" />
<col width="27%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Collapse operators</th>
<th class="head">Expectation operators</th>
<th class="head">Number of requested outputs</th>
<th class="head">Return value(s)</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>NO</td>
<td>NO</td>
<td>1</td>
<td>List of state vectors</td>
</tr>
<tr class="row-odd"><td>NO</td>
<td>YES</td>
<td>1</td>
<td>List of expectation values</td>
</tr>
<tr class="row-even"><td>YES</td>
<td>NO</td>
<td>1</td>
<td>List of state vectors for each
trajectory.</td>
</tr>
<tr class="row-odd"><td>YES</td>
<td>NO</td>
<td>2</td>
<td>List of state vectors for each
trajectory + List of collapse times
for each trajectory.</td>
</tr>
<tr class="row-even"><td>YES</td>
<td>NO</td>
<td>3</td>
<td>List of state vectors for each
trajectory + List of collapse times
for each trajectory + List of which
operator did collapse for each
trajectory.</td>
</tr>
<tr class="row-odd"><td>YES</td>
<td>YES</td>
<td>1</td>
<td>List of expectation values for each
trajectory.</td>
</tr>
<tr class="row-even"><td>YES</td>
<td>YES</td>
<td>2</td>
<td>List of expectation values for each
trajectory + List of collapse times
for each trajectory.</td>
</tr>
<tr class="row-odd"><td>YES</td>
<td>YES</td>
<td>3</td>
<td>List of expectation values for each
trajectory + List of collapse times
for each trajectory + List of which
operator did collapse for each
trajectory.</td>
</tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="dynamics-bloch-redfield.html" title="Bloch-Redfield master equation"
             >next</a> |</li>
        <li class="right" >
          <a href="dynamics-master.html" title="Lindblad Master Equation Solver"
             >previous</a> |</li>
        <li><a href="../../index.html">home</a>|&nbsp;</li>
        <li><a href="../../search.html">search</a>|&nbsp;</li>

          <li><a href="../guide.html" >QuTiP Users Guide</a> &raquo;</li>
          <li><a href="../guide-dynamics.html" >Evaluating Quantum System Dynamics</a> &raquo;</li> 
      </ul>
    </div>

    <div class="footer">
        &copy; Copyright 2011-2012, P.D. Nation, J.R. Johansson.
      Last updated on May 16, 2012.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-16824831-3");
pageTracker._trackPageview();
} catch(err) {}</script>

  </body>
</html>